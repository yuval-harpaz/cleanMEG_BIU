
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>correctHB</title><meta name="generator" content="MATLAB 7.13"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2014-12-11"><meta name="DC.source" content="correctHBcdb.m"><style type="text/css">

body {
  background-color: white;
  margin:10px;
}

h1 {
  color: #990000; 
  font-size: x-large;
}

h2 {
  color: #990000;
  font-size: medium;
}

/* Make the text shrink to fit narrow windows, but not stretch too far in 
wide windows. */ 
p,h1,h2,div.content div {
  max-width: 600px;
  /* Hack for IE6 */
  width: auto !important; width: 600px;
}

pre.codeinput {
  background: #EEEEEE;
  padding: 10px;
}
@media print {
  pre.codeinput {word-wrap:break-word; width:100%;}
} 

span.keyword {color: #0000FF}
span.comment {color: #228B22}
span.string {color: #A020F0}
span.untermstring {color: #B20000}
span.syscmd {color: #B28C00}

pre.codeoutput {
  color: #666666;
  padding: 10px;
}

pre.error {
  color: red;
}

p.footer {
  text-align: right;
  font-size: xx-small;
  font-weight: lighter;
  font-style: italic;
  color: gray;
}

  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#3">cfg</a></li><li><a href="#4">default variables and parameters</a></li><li><a href="#5">checking defaults for 4D data</a></li><li><a href="#6">pad with zeros for templite slide</a></li><li><a href="#7">Filter data if requested</a></li><li><a href="#8">filter mean MEG (or ECG)</a></li><li><a href="#9">look for a noisy segment and noisy channels</a></li><li><a href="#10">peak detection on MCG (or ECG) signal</a></li><li><a href="#11">get topography</a></li><li><a href="#12">check if topo of every peak is correlated to average topo</a></li><li><a href="#13">average good HB and make a template</a></li><li><a href="#14">find xcorr between template and meanMEG</a></li><li><a href="#15">second sweep</a></li><li><a href="#16">find peaks on xcorr trace</a></li><li><a href="#17">test R amplitude</a></li><li><a href="#18">remove mcg from each chan</a></li><li><a href="#19">Plot average MEG channel before and after</a></li><li><a href="#20">Plot average HB (on average MEG) before and after</a></li><li><a href="#21">sanity check</a></li><li><a href="#22">internal functions</a></li></ul></div><pre class="codeinput"><span class="keyword">function</span> [data,HBtimes,templateHB,Period,MCG,Rtopo]=correctHBcdb(data,sRate,figOptions,ECG,cfg)
</pre><pre class="codeinput"><span class="comment">% - data is a matrix with rows for channels, raw data, not filtered. it can</span>
<span class="comment">% also be a filename.mat, directing to data matrix file, or a 4D filename such</span>
<span class="comment">% as 'c1,rfhp0.1Hz'.</span>
<span class="comment">% - sRate is sampling rate</span>
<span class="comment">% - figOptions=false;</span>
<span class="comment">% if you want fieldtrip topoplot of HB (first and second sweeps) you have to have:</span>
<span class="comment">% figOptions.label=N by 1 cell arraay with channel names of data</span>
<span class="comment">% figOptions.layout='4D248.lay' for 4D users. I recommend</span>
<span class="comment">% 'neuromag306mag.lay' for neuromag users even if data includes also grads.</span>
<span class="comment">% - ECG can be ECG (useful for ctf users) or a mean of subset of MEG channels where the HB is</span>
<span class="comment">% visible. neuromag users can put there the mean of the magnetometers to</span>
<span class="comment">% clean both magnetometers and gradiometers included in data.</span>
<span class="comment">%</span>
<span class="comment">% HB components</span>
<span class="comment">%     /\      _____         /\      _____</span>
<span class="comment">% __ /  \  __/     \______ /  \  __/     \__...</span>
<span class="comment">%   /    \/               /    \/</span>
<span class="comment">%   Q  R  S     T</span>
<span class="comment">%</span>
<span class="comment">%</span>
</pre><h2>cfg<a name="3"></a></h2><p>you can change variables by placing them in cfg. lots of thresholds can be set and filters factors.</p><p>a bit about the FILTERS. PEAK detection is performed on meanMEGf. a highpass is recommended to eliminate drift, but also the T wave which is sometimes larger than the R. cfg.peakFiltFreq sets the bandpass freqs for this one. the AMPLITUDE of R is estimated, but then you may want a highpass filter only, not to cut down R peak. cfg.ampFiltFreq can set up this filter as bp or hp. when using xcorr or Abeles method a TEMPLATE HB is fitted to the ECG like trace (meanMEG). another filter can be used there, in order to supress T for better timing. when the R is small and T can help the template match leave some low frequencies in. use tempFiltFreq for this one. I added filtering option dataFiltFreq for the data (and meanMEG) to get rid of low frequencies (DC recordings). not performed by default.</p><pre>- cfg.chanSnrThr (default 0) is the threshold (in z scores) that tell which channels are cleaned and which
remain as are. use 0 to clean all.</pre><pre>- cfg.rThr (0.5) is the threshold for correlation between topographies of averaged R peak
and a particular R peak, it determains which instances of HB will be
taken to calculate the HB temporal template</pre><pre>- cfg.minPeriod (0.45) low limit for HB period</pre><pre>- cfg.maxPeriod (2) upper limit for HB period</pre><pre>- cfg.chanZthr (20) z-score for declaring bad channels. A channel is bad
if it surpasses this value for 3 seconds in the beginning of the</pre><pre>- cfg.jPad (1) how much to zero pad before and after jump</pre><pre>- cfg.jZthr (15) is a z-score over which the meanMEG is considered to
have jump artifact</pre><pre>- cfg.peakFiltFreq ([7 90]) is the band-pass filter used for the meanMEG data, before peak
detection.</pre><pre>- cfg.tempFiltFreq (same as peakFiltFreq) is the filter used for
meanMEG template and meanMEG before template match takes place. when
T is large and R is small you may want to lower the highpass freq. It
can save the day but beware, tricky business.</pre><pre>- cfg.matchMethod can be 'xcorr' (default) or 'Abeles', it is how you find
the match between a template HB and meanMEG / ECG recording. you can also
use 'topo' and 'meanMEG' in order to define HB peaks on the topography
trace or the mean(MEG) channel.</pre><pre>- cfg.ampFiltFreq (2) is a high-pass or band-pass filter used to test R
peak amplitude. better use highpass only, although bp may improve linear
fit between (unfiltered) template and filtered data.</pre><pre>- cfg.ampLinThr (0.25) is linear regression r threshold. if there is no ggood
fit between template QRS and an instance of a heart beat, amplitude will not
be assesed by r, the average HB amp will be given.</pre><pre>- cfg.afterHBs (0.7 of the period) is how long the template should continue after the
peak (seconds)</pre><pre>- cfg.beforeHBs (0.3 of the period) is when the template should start before the
peak (seconds)</pre><pre>- cfg.repressTime (20ms) is how much of the template to repress to zero on
the edges (ms)</pre><p>4D users can run the function from the folder with the data ('c,*') file, with no input arguments: cleanData=correctHB; or like this cleanData=correctHB([],[],1); to get the figures. if you don't specify figure options you still get one before / after figure. added by Dr. Yuval Harpaz to Prof. Abeles' work</p><p>Issues:</p><p>- only R amplitude is corrected, may consider to change q s and t waves.</p><p>- allow using a premade template, good for cleaning data in 2 pieces</p><p>it works, try it!</p><h2>default variables and parameters<a name="4"></a></h2><pre class="codeinput"><span class="keyword">if</span> ~exist(<span class="string">'figOptions'</span>,<span class="string">'var'</span>)
    figOptions=1;
<span class="keyword">end</span>
<span class="keyword">if</span> isempty(figOptions)
    figs=false;
<span class="keyword">else</span>
    figs=true;
<span class="keyword">end</span>
<span class="keyword">if</span> ~exist(<span class="string">'ECG'</span>,<span class="string">'var'</span>)
    ECG=[];
<span class="keyword">end</span>
<span class="keyword">if</span> ~exist(<span class="string">'cfg'</span>,<span class="string">'var'</span>)
    cfg=struct;
<span class="keyword">end</span>
<span class="comment">% uses default unless specified in the cfg</span>
chanSnrThr=default(<span class="string">'chanSnrThr'</span>,0,cfg);
rThr=default(<span class="string">'rThr'</span>,0.5,cfg);
peakZthr=default(<span class="string">'peakZthr'</span>,1.5,cfg);
minPeriod=default(<span class="string">'minPeriod'</span>,0.45,cfg);
maxPeriod=default(<span class="string">'maxPeriod'</span>,2,cfg);
chanZthr=default(<span class="string">'chanZthr'</span>,20,cfg);
jPad=default(<span class="string">'jPad'</span>,1,cfg);
jZthr=default(<span class="string">'jZthr'</span>,15,cfg);
peakFiltFreq=default(<span class="string">'peakFiltFreq'</span>,[7 90],cfg);
ampFiltFreq=default(<span class="string">'ampFiltFreq'</span>,2,cfg);<span class="comment">% [7 90] for band pass</span>
tempFiltFreq=default(<span class="string">'tempFiltFreq'</span>,peakFiltFreq,cfg);
dataFiltFreq=default(<span class="string">'dataFiltFreq'</span>,[],cfg);
matchMethod=default(<span class="string">'matchMethod'</span>,<span class="string">'xcorr'</span>,cfg);
beforeHBs=default(<span class="string">'beforeHBs'</span>,[],cfg); <span class="comment">% how long the right side of template HB should be. when empty it gets 0.3*period</span>
afterHBs=default(<span class="string">'afterHBs'</span>,[],cfg); <span class="comment">% how long the right side of template HB should be. when empty it gets 0.7*period</span>
ampLinThr=default(<span class="string">'ampLinThr'</span>,0.25,cfg);  <span class="comment">% threshold for low amplitude HB, use average amplitude when below this ratio</span>
</pre><h2>checking defaults for 4D data<a name="5"></a></h2><p>to use with data=[] and sRate=[];</p><pre class="codeinput"><span class="keyword">if</span> ~exist(<span class="string">'data'</span>,<span class="string">'var'</span>)
    data=[];
    sRate=[];
<span class="keyword">end</span>
<span class="keyword">if</span> ischar(data)
    <span class="keyword">if</span> strcmp(data(end-3:end),<span class="string">'.mat'</span>) <span class="comment">% read matrix from file 'data.mat'</span>
        PWD=pwd;
        display([<span class="string">'loading '</span>,PWD,<span class="string">'/'</span>,data,]);
        data=load([<span class="string">'./'</span>,data]);
        dataField=fieldnames(data);

        eval([<span class="string">'data=data.'</span>,dataField{1,1},<span class="string">';'</span>]);
    <span class="keyword">else</span> <span class="comment">% read 4D data from file name specified in 'data'</span>
        cloc=strfind(data,<span class="string">'c'</span>);
        comaloc=strfind(data,<span class="string">','</span>);
        <span class="keyword">if</span> ~isempty(cloc) &amp;&amp; ~isempty(comaloc)
            <span class="keyword">if</span> comaloc(end)&gt;cloc(1)
                var4DfileName=data;
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">if</span> isempty(data) || exist(<span class="string">'var4DfileName'</span>,<span class="string">'var'</span>);
    <span class="keyword">if</span> ~exist(<span class="string">'var4DfileName'</span>,<span class="string">'var'</span>);
        <span class="keyword">try</span>
            var4DfileName=ls(<span class="string">'xc,lf_c,*'</span>);
        <span class="keyword">catch</span> <span class="comment">%#ok&lt;CTCH&gt;</span>
            var4DfileName=ls(<span class="string">'c,*'</span>);
        <span class="keyword">end</span>
        var4DfileName=[<span class="string">'./'</span>,var4DfileName(1:end-1)];
    <span class="keyword">end</span>

    var4Dp=pdf4D(var4DfileName);
    sRate=double(get(var4Dp,<span class="string">'dr'</span>));
    var4Dhdr = get(var4Dp, <span class="string">'header'</span>);
    var4DnSamp=var4Dhdr.epoch_data{1,1}.pts_in_epoch;
    var4Dchi = channel_index(var4Dp, <span class="string">'meg'</span>, <span class="string">'name'</span>);
    display([<span class="string">'reading '</span>,var4DfileName]);
    data = read_data_block(var4Dp,[1 var4DnSamp],var4Dchi);
    <span class="comment">%data=double(data);</span>
    <span class="keyword">if</span> figs
        var4Dlabel=channel_label(var4Dp,var4Dchi)';
        <span class="keyword">if</span> figOptions==1;
            clear <span class="string">figOptions</span>
        <span class="keyword">end</span>
        figOptions.label=var4Dlabel;
        figOptions.layout=<span class="string">'4D248.lay'</span>;
    <span class="keyword">end</span>
    clear <span class="string">var4D*</span>
<span class="keyword">end</span>

<span class="keyword">if</span> ~isempty(ECG)
    meanMEG=ECG;
    <span class="comment">%meanMEGdt=detrend(meanMEG,'linear',round(sRate:sRate:length(meanMEG)));</span>
<span class="keyword">else</span>
    meanMEG=double(mean(data));
<span class="keyword">end</span>
repressTime=default(<span class="string">'repressTime'</span>,round(sRate/50),cfg);
</pre><h2>pad with zeros for templite slide<a name="6"></a></h2><pre class="codeinput">sampBefore=round(sRate*maxPeriod);
<span class="comment">%time=1/sRate:1/sRate:size(data,2)/sRate;</span>
time=-sampBefore/sRate:1/sRate:(size(data,2)+sampBefore)/sRate;
time=time(2:end);
origDataSize=size(data);
meanMEG=[zeros(1,sampBefore),meanMEG,zeros(1,sampBefore)];
data=[zeros(size(data,1),sampBefore),data,zeros(size(data,1),sampBefore)];

realDataSamp=[sampBefore+1,size(data,2)-sampBefore];
</pre><h2>Filter data if requested<a name="7"></a></h2><pre class="codeinput"><span class="keyword">if</span> ~isempty(dataFiltFreq)
    display(<span class="string">'filtering the data'</span>)
    <span class="keyword">if</span> length(dataFiltFreq)==2
        Fp1=dataFiltFreq(1);
        Fst1=max([0.01,Fp1-1]);
        ObjData=fdesign.bandpass(<span class="keyword">...</span>
            <span class="string">'Fst1,Fp1,Fp2,Fst2,Ast1,Ap,Ast2'</span>,<span class="keyword">...</span>
            Fst1,Fp1,dataFiltFreq(2),dataFiltFreq(2)+10,60,1,60,sRate);
    <span class="keyword">elseif</span> length(dataFiltFreq)==1
        <span class="keyword">if</span> dataFiltFreq&lt;15
            ObjData=fdesign.highpass(<span class="string">'Fst,Fp,Ast,Ap'</span>,max([dataFiltFreq-1,0.01]),dataFiltFreq,60,1,sRate);<span class="comment">%</span>
        <span class="keyword">elseif</span> dataFiltFreq&gt;=15
            ObjData=fdesign.lowpass(<span class="string">'Fp,Fst,Ap,Ast'</span>,dataFiltFreq,dataFiltFreq+10,1,60,sRate);
        <span class="keyword">end</span>
        FiltData=design(ObjData ,<span class="string">'butter'</span>);
    <span class="keyword">end</span>
    data = myFilt(data,FiltData);
    meanMEG=myFilt(meanMEG,FiltData);
<span class="keyword">end</span>

<span class="keyword">for</span> chani=1:size(data,1)
    data(chani,:)=data(chani,:)-median(data(chani,:));
<span class="keyword">end</span>
meanMEG=meanMEG-median(meanMEG);
</pre><h2>filter mean MEG (or ECG)<a name="8"></a></h2><p>filtering to pass from 5-7Hz to 90-110Hz</p><pre class="codeinput"><span class="keyword">if</span> ~(peakFiltFreq(1)&gt;1)
    Fst1=0.001;
<span class="keyword">else</span>
    Fst1=peakFiltFreq(1)-1;
<span class="keyword">end</span>
BandPassSpecObj=fdesign.bandpass(<span class="keyword">...</span>
    <span class="string">'Fst1,Fp1,Fp2,Fst2,Ast1,Ap,Ast2'</span>,<span class="keyword">...</span>
    Fst1,peakFiltFreq(1),peakFiltFreq(2),peakFiltFreq(2)+10,60,1,60,sRate);
BandPassFilt=design(BandPassSpecObj ,<span class="string">'butter'</span>);
meanMEGf = myFilt(meanMEG,BandPassFilt);
<span class="comment">% baseline correction again, just in case</span>
meanMEGf=meanMEGf-median(meanMEGf);
</pre><h2>look for a noisy segment and noisy channels<a name="9"></a></h2><p>find bad channels, has to be noisy for 3 of the first 3 seconds</p><pre class="codeinput">stdMEG=std(data(:,1:round(sRate))');
badc1=stdMEG&gt;chanZthr*median(stdMEG);
stdMEG=std(data(:,round(sRate):round(2*sRate))');
badc2=stdMEG&gt;chanZthr*median(stdMEG);
stdMEG=std(data(:,round(2*sRate):round(3*sRate))');
badc3=stdMEG&gt;chanZthr*median(stdMEG);
badc=find((badc1+badc2+badc3)==3);
<span class="keyword">if</span> ~isempty(badc)
    data(badc,:)=0;
<span class="keyword">end</span>

<span class="comment">% find jump or other huge artifact</span>
zMEG=(meanMEGf-mean(meanMEGf))./std(meanMEGf);
jbeg=find(abs((zMEG))&gt;jZthr,1);<span class="comment">%</span>
j=find(abs((zMEG))&gt;jZthr);
bads=[]; <span class="comment">% bad samples</span>
<span class="keyword">if</span> ~isempty(jbeg)
    <span class="comment">%jend=find(abs((zMEG))&gt;zThr,1,'last');</span>
    <span class="comment">%jend2=find(abs(zMEG(jend:end))&gt;1,1,'last')+jend-1;</span>
    <span class="keyword">for</span> jumpi=1:length(j)
        bads=[bads,j(jumpi)-round(sRate*jPad):j(jumpi)+sRate*jPad]; <span class="comment">%#ok&lt;AGROW&gt;</span>
    <span class="keyword">end</span>
    <span class="comment">%bads(bads&lt;sampBefore+1)=sampBefore+1;</span>
    bads=unique(bads);
    bads=bads(bads&gt;0);
    badData=data(:,bads);
    <span class="comment">%bads=(jbeg-round(sRate./2)):(jend2+round(sRate*0.5));</span>
    data(:,bads)=0;
    <span class="keyword">if</span> length(data)&lt;2^19
        data=data-repmat(median(data,2),1,size(data,2));
    <span class="keyword">else</span>
        <span class="keyword">for</span> chani=1:size(data,1)
            data(chani,:)=data(chani,:)-median(data(chani,:),2);
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    diary(<span class="string">'HBlog.txt'</span>)
    warning([<span class="string">'jump? what'''</span>,<span class="string">'s the noise at '</span>,num2str(time(jbeg)),<span class="string">'s? zeroed noise from '</span>,num2str(max([0,time(bads(1))])),<span class="string">' to '</span>,num2str(time(bads(end)))]);
    diary <span class="string">off</span>
    <span class="comment">% end</span>
<span class="keyword">else</span>
    <span class="comment">% baseline correction by removing the median of each channel</span>
    <span class="keyword">if</span> length(data)&lt;2^19
        data=data-repmat(median(data,2),1,size(data,2));
    <span class="keyword">else</span>
         <span class="keyword">for</span> chani=1:size(data,1)
            data(chani,:)=data(chani,:)-median(data(chani,:),2);
         <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="keyword">if</span> isempty(ECG)
    meanMEG=double(mean(data));
    meanMEGf = myFilt(meanMEG,BandPassFilt);
    meanMEGf=meanMEGf-median(meanMEGf);
<span class="keyword">end</span>
</pre><h2>peak detection on MCG (or ECG) signal<a name="10"></a></h2><pre class="codeinput">disp(<span class="string">'looking for HB peaks'</span>)
[peaks, Ipeaks]=findPeaks(meanMEGf,peakZthr,round(sRate*minPeriod)); <span class="comment">% 450ms interval minimum</span>
<span class="comment">% test if, by chance, the HB field is mainly negative</span>
posHB=true;
<span class="keyword">if</span> isempty(ECG)
        [peaksNeg, IpeaksNeg]=findPeaks(-meanMEGf,peakZthr,round(sRate*minPeriod));
    <span class="keyword">if</span> median(peaksNeg)/median(peaks)&gt;1.1
        diary(<span class="string">'HBlog.txt'</span>)
        warning(<span class="string">'NEGATIVE HB FIELD? if not, average selected MEG channels and give it as ECG'</span>);
        diary <span class="string">off</span>
        period1=median(diff(IpeaksNeg))./sRate;
        <span class="keyword">if</span> period1&lt;2
            [peaks, Ipeaks]=findPeaks(-meanMEGf,peakZthr,round(sRate*period1*0.6));
            peaks=-peaks;
        <span class="keyword">else</span>
            Ipeaks=IpeaksNeg;
            peaks=-peaksNeg;
        <span class="keyword">end</span>
        posHB=false;
        <span class="comment">%meanMEGf=-meanMEGf;</span>
    <span class="keyword">else</span>
        period1=median(diff(Ipeaks))./sRate;
        <span class="keyword">if</span> period1&lt;2 <span class="comment">%#ok&lt;*BDSCI&gt; %try to improve peak detection if peak intervals are reasonable</span>
            [peaks, Ipeaks]=findPeaks(meanMEGf,peakZthr,round(sRate*period1*0.6)); <span class="comment">% 450ms interval</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="keyword">if</span> figs
    figure;
    plot(time,meanMEGf)
    hold <span class="string">on</span>
    plot(time(Ipeaks), peaks,<span class="string">'ro'</span>)
    title(<span class="string">'Peak detection on mean MEG (or ECG) trace, OK if many of them are not HB'</span>)
<span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="correctHBcdb_01.png" alt=""> <h2>get topography<a name="11"></a></h2><pre class="codeinput"><span class="keyword">if</span> figs
    <span class="keyword">if</span> isfield(figOptions,<span class="string">'layout'</span>) &amp;&amp; isfield(figOptions,<span class="string">'label'</span>)
        topo={};
        topo.avg=median(data(:,Ipeaks),2);
        topo.time=0;
        topo.label=figOptions.label;
        topo.dimord=<span class="string">'chan_time'</span>;
        cfgp=[];
        cfgp.layout=figOptions.layout;
        <span class="keyword">if</span> ~isempty(badc)
            cfgp.channel=setdiff(1:length(topo.label),badc);
        <span class="keyword">end</span>
        <span class="keyword">if</span> strcmp(cfgp.layout,<span class="string">'neuromag306mag.lay'</span>)
            [~,magi]=ismember({<span class="string">'MEG0111'</span>;<span class="string">'MEG0121'</span>;<span class="string">'MEG0131'</span>;<span class="string">'MEG0141'</span>;<span class="string">'MEG0211'</span>;<span class="string">'MEG0221'</span>;<span class="string">'MEG0231'</span>;<span class="string">'MEG0241'</span>;<span class="string">'MEG0311'</span>;<span class="string">'MEG0321'</span>;<span class="string">'MEG0331'</span>;<span class="string">'MEG0341'</span>;<span class="string">'MEG0411'</span>;<span class="string">'MEG0421'</span>;<span class="string">'MEG0431'</span>;<span class="string">'MEG0441'</span>;<span class="string">'MEG0511'</span>;<span class="string">'MEG0521'</span>;<span class="string">'MEG0531'</span>;<span class="string">'MEG0541'</span>;<span class="string">'MEG0611'</span>;<span class="string">'MEG0621'</span>;<span class="string">'MEG0631'</span>;<span class="string">'MEG0641'</span>;<span class="string">'MEG0711'</span>;<span class="string">'MEG0721'</span>;<span class="string">'MEG0731'</span>;<span class="string">'MEG0741'</span>;<span class="string">'MEG0811'</span>;<span class="string">'MEG0821'</span>;<span class="string">'MEG0911'</span>;<span class="string">'MEG0921'</span>;<span class="string">'MEG0931'</span>;<span class="string">'MEG0941'</span>;<span class="string">'MEG1011'</span>;<span class="string">'MEG1021'</span>;<span class="string">'MEG1031'</span>;<span class="string">'MEG1041'</span>;<span class="string">'MEG1111'</span>;<span class="string">'MEG1121'</span>;<span class="string">'MEG1131'</span>;<span class="string">'MEG1141'</span>;<span class="string">'MEG1211'</span>;<span class="string">'MEG1221'</span>;<span class="string">'MEG1231'</span>;<span class="string">'MEG1241'</span>;<span class="string">'MEG1311'</span>;<span class="string">'MEG1321'</span>;<span class="string">'MEG1331'</span>;<span class="string">'MEG1341'</span>;<span class="string">'MEG1411'</span>;<span class="string">'MEG1421'</span>;<span class="string">'MEG1431'</span>;<span class="string">'MEG1441'</span>;<span class="string">'MEG1511'</span>;<span class="string">'MEG1521'</span>;<span class="string">'MEG1531'</span>;<span class="string">'MEG1541'</span>;<span class="string">'MEG1611'</span>;<span class="string">'MEG1621'</span>;<span class="string">'MEG1631'</span>;<span class="string">'MEG1641'</span>;<span class="string">'MEG1711'</span>;<span class="string">'MEG1721'</span>;<span class="string">'MEG1731'</span>;<span class="string">'MEG1741'</span>;<span class="string">'MEG1811'</span>;<span class="string">'MEG1821'</span>;<span class="string">'MEG1831'</span>;<span class="string">'MEG1841'</span>;<span class="string">'MEG1911'</span>;<span class="string">'MEG1921'</span>;<span class="string">'MEG1931'</span>;<span class="string">'MEG1941'</span>;<span class="string">'MEG2011'</span>;<span class="string">'MEG2021'</span>;<span class="string">'MEG2031'</span>;<span class="string">'MEG2041'</span>;<span class="string">'MEG2111'</span>;<span class="string">'MEG2121'</span>;<span class="string">'MEG2131'</span>;<span class="string">'MEG2141'</span>;<span class="string">'MEG2211'</span>;<span class="string">'MEG2221'</span>;<span class="string">'MEG2231'</span>;<span class="string">'MEG2241'</span>;<span class="string">'MEG2311'</span>;<span class="string">'MEG2321'</span>;<span class="string">'MEG2331'</span>;<span class="string">'MEG2341'</span>;<span class="string">'MEG2411'</span>;<span class="string">'MEG2421'</span>;<span class="string">'MEG2431'</span>;<span class="string">'MEG2441'</span>;<span class="string">'MEG2511'</span>;<span class="string">'MEG2521'</span>;<span class="string">'MEG2531'</span>;<span class="string">'MEG2541'</span>;<span class="string">'MEG2611'</span>;<span class="string">'MEG2621'</span>;<span class="string">'MEG2631'</span>;<span class="string">'MEG2641'</span>},topo.label);
            <span class="comment">%topo.avg=topo.avg(chi);</span>
            <span class="comment">%topo.label=topo.label(chi);</span>
            cfgp.xlim=[1,1];
            cfgp.zlim=[-max(abs(topo.avg(magi))) max(abs(topo.avg(magi)))];
            figure;
            ft_topoplotER(cfgp,topo);
            title(<span class="string">'MAGNETOMETERS, TOPOGRAPHY OF R'</span>)
            <span class="comment">% cfg.layout='neuromag306planar.lay';</span>
            <span class="comment">% grd=topo.avg;</span>
            <span class="comment">% grd(chi)=0;</span>
            <span class="comment">% cfg.zlim=[-max(abs(grd)) max(abs(grd))];</span>
            <span class="comment">% figure;</span>
            <span class="comment">% ft_topoplotER(cfg,topo);</span>
            <span class="comment">% title('GRADIOMETERS')</span>
        <span class="keyword">else</span>
            <span class="comment">%cfg.channel={'MEG0111';'MEG0121';'MEG0131';'MEG0141';'MEG0211';'MEG0221';'MEG0231';'MEG0241';'MEG0311';'MEG0321';'MEG0331';'MEG0341';'MEG0411';'MEG0421';'MEG0431';'MEG0441';'MEG0511';'MEG0521';'MEG0531';'MEG0541';'MEG0611';'MEG0621';'MEG0631';'MEG0641';'MEG0711';'MEG0721';'MEG0731';'MEG0741';'MEG0811';'MEG0821';'MEG0911';'MEG0921';'MEG0931';'MEG0941';'MEG1011';'MEG1021';'MEG1031';'MEG1041';'MEG1111';'MEG1121';'MEG1131';'MEG1141';'MEG1211';'MEG1221';'MEG1231';'MEG1241';'MEG1311';'MEG1321';'MEG1331';'MEG1341';'MEG1411';'MEG1421';'MEG1431';'MEG1441';'MEG1511';'MEG1521';'MEG1531';'MEG1541';'MEG1611';'MEG1621';'MEG1631';'MEG1641';'MEG1711';'MEG1721';'MEG1731';'MEG1741';'MEG1811';'MEG1821';'MEG1831';'MEG1841';'MEG1911';'MEG1921';'MEG1931';'MEG1941';'MEG2011';'MEG2021';'MEG2031';'MEG2041';'MEG2111';'MEG2121';'MEG2131';'MEG2141';'MEG2211';'MEG2221';'MEG2231';'MEG2241';'MEG2311';'MEG2321';'MEG2331';'MEG2341';'MEG2411';'MEG2421';'MEG2431';'MEG2441';'MEG2511';'MEG2521';'MEG2531';'MEG2541';'MEG2611';'MEG2621';'MEG2631';'MEG2641'};</span>
            <span class="comment">%cfg.interpolation='linear';</span>
            cfgp.xlim=[1,1];
            cfgp.zlim=[-max(abs(topo.avg)) max(abs(topo.avg))];
            figure;
            ft_topoplotER(cfgp,topo);
            title(<span class="string">'TOPOGRAPHY OF R'</span>)

        <span class="keyword">end</span>
    <span class="keyword">else</span>
        warning(<span class="string">'no topoplot without labels and layout fields! see figOptions options'</span>)
    <span class="keyword">end</span>
<span class="keyword">end</span>
topoTrace=median(data(:,Ipeaks),2)'*data;
topoTrace=myFilt(topoTrace,BandPassFilt);
topoTrace=topoTrace-median(topoTrace);
<span class="comment">% if ~posHB</span>
<span class="comment">%     meanMEGN=meanMEGf./max(-meanMEGf(1:round(sRate*10)));</span>
<span class="comment">%     topoTraceN=-topoTrace./max(topoTrace(1:round(sRate*10)));</span>
<span class="comment">% else</span>
<span class="comment">%     topoTraceN=topoTrace./max(topoTrace(1:round(sRate*10)));</span>
<span class="comment">%     meanMEGN=meanMEGf./max(meanMEGf(1:round(sRate*10)));</span>
<span class="comment">% end</span>
meanMEGN=standard(meanMEGf);
topoTraceN=standard(topoTrace);
<span class="keyword">if</span> ~posHB
    topoTraceN=-topoTraceN;
<span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="correctHBcdb_02.png" alt=""> <h2>check if topo of every peak is correlated to average topo<a name="12"></a></h2><pre class="codeinput">r=corr(data(:,Ipeaks),median(data(:,Ipeaks),2));
<span class="keyword">if</span> figs
    figure;
    plot(time,topoTraceN)
    hold <span class="string">on</span>
    plot(time,meanMEGN,<span class="string">'r'</span>)
    plot(time(Ipeaks(r&gt;0.5)),meanMEGN(Ipeaks(r&gt;0.5)),<span class="string">'g.'</span>);
    legend(<span class="string">'topoTrace'</span>,<span class="string">'meanMEG'</span>,<span class="string">'r data-topo &gt; 0.5'</span>)

<span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="correctHBcdb_03.png" alt=""> <img vspace="5" hspace="5" src="correctHBcdb_04.png" alt=""> <h2>average good HB and make a template<a name="13"></a></h2><pre class="codeinput">IpeaksR=Ipeaks(r&gt;0.5);
IpeaksR=IpeaksR(IpeaksR&gt;sampBefore);
IpeaksR=IpeaksR(IpeaksR&lt;(size(data,2)-sampBefore));
period2=diff(IpeaksR)/sRate; <span class="comment">% estimate period</span>
period2=median(period2(period2&lt;maxPeriod)); <span class="comment">% less than 2s</span>

<span class="comment">%LowPassSpecObj=fdesign.lowpass('Fp,Fst,Ap,Ast',45,55,1,60,sRate);</span>
<span class="keyword">if</span> tempFiltFreq==peakFiltFreq
    meanMEGxcrF=meanMEGf;
<span class="keyword">else</span>
    <span class="keyword">if</span> length(tempFiltFreq)==2
        Fp1=tempFiltFreq(1);
        Fst1=max([0.01,Fp1-1]);
        ObjXcr=fdesign.bandpass(<span class="keyword">...</span>
            <span class="string">'Fst1,Fp1,Fp2,Fst2,Ast1,Ap,Ast2'</span>,<span class="keyword">...</span>
            Fst1,Fp1,tempFiltFreq(2),tempFiltFreq(2)+10,60,1,60,sRate);
    <span class="keyword">elseif</span> length(tempFiltFreq)==1
        <span class="keyword">if</span> tempFiltFreq&lt;15
            ObjXcr=fdesign.highpass(<span class="string">'Fst,Fp,Ast,Ap'</span>,max([tempFiltFreq-1,0.01]),tempFiltFreq,60,1,sRate);<span class="comment">%</span>
        <span class="keyword">elseif</span> tempFiltFreq&gt;=15
            ObjXcr=fdesign.lowpass(<span class="string">'Fp,Fst,Ap,Ast'</span>,tempFiltFreq,tempFiltFreq+10,1,60,sRate);
        <span class="keyword">end</span>
        FiltXcr=design(ObjXcr ,<span class="string">'butter'</span>);
        meanMEGxcrF = myFilt(meanMEG,FiltXcr);
    <span class="keyword">end</span>
<span class="keyword">end</span>


<span class="comment">% meanMEGxcrF = myFilt(meanMEG,BandPassFiltXcr);</span>
meanMEGxcrF=meanMEGxcrF-median(meanMEGxcrF);
<span class="keyword">if</span> posHB
    [temp1e,period3]=makeTempHB(meanMEGxcrF,sRate,IpeaksR,period2,sampBefore,figs,maxPeriod);
<span class="keyword">else</span>
    [temp1e,period3]=makeTempHB(-meanMEGxcrF,sRate,IpeaksR,period2,sampBefore,figs,maxPeriod);
<span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="correctHBcdb_05.png" alt=""> <h2>find xcorr between template and meanMEG<a name="14"></a></h2><pre class="codeinput">maxi=round(0.3*length(temp1e))+1; <span class="comment">%maxi is where the R peak in the template</span>
[~,mi]=max(temp1e(maxi-round(sRate/100):maxi+round(sRate/100)));
maxi=maxi-round(sRate/100)+mi-1;
<span class="keyword">if</span> posHB
    meanMEGpos=meanMEGxcrF;
<span class="keyword">else</span>
    meanMEGpos=-meanMEGxcrF;
<span class="keyword">end</span>
<span class="keyword">switch</span> matchMethod
    <span class="keyword">case</span> <span class="string">'xcorr'</span>
        matchTrace=XCORR(meanMEGpos,temp1e,maxi);
    <span class="keyword">case</span> <span class="string">'Abeles'</span>
        [snr,signal]=match_temp(meanMEGxcrF,temp1e,maxi);
        matchTrace=snr;
    <span class="keyword">case</span> <span class="string">'topo'</span>
        matchTrace=topoTrace;
    <span class="keyword">case</span> <span class="string">'meanMEG'</span>
        matchTrace=meanMEGf;
<span class="keyword">end</span>


<span class="keyword">if</span> figs
    figure;
    plot(time,topoTraceN)
    hold <span class="string">on</span>
    plot(time,meanMEGN,<span class="string">'r'</span>)
    <span class="keyword">if</span> posHB
        plot(time,standard(matchTrace),<span class="string">'g'</span>);
    <span class="keyword">else</span>
        plot(time,-standard(matchTrace),<span class="string">'g'</span>);
    <span class="keyword">end</span>
    legend(<span class="string">'topoTrace'</span>,<span class="string">'meanMEG'</span>,<span class="string">'temp xcorr'</span>)
<span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="correctHBcdb_06.png" alt=""> <h2>second sweep<a name="15"></a></h2><h2>find peaks on xcorr trace<a name="16"></a></h2><pre class="codeinput">[peaks2, Ipeaks2]=findPeaks(matchTrace,peakZthr,round(sRate*period3*0.65)); <span class="comment">% no peaks closer than 60% of period</span>
<span class="keyword">if</span> figs
    figure;
    <span class="keyword">if</span> posHB
        plot(time,matchTrace)
        hold <span class="string">on</span>
        plot(time(Ipeaks2), peaks2,<span class="string">'ro'</span>)
    <span class="keyword">else</span>
        plot(time,-matchTrace)
        hold <span class="string">on</span>
        plot(time(Ipeaks2), -peaks2,<span class="string">'ro'</span>)
    <span class="keyword">end</span>
    title(<span class="string">'2nd sweep peak detection, based on template matching'</span>)
<span class="keyword">end</span>
<span class="comment">% checking results</span>
periodS=diff(Ipeaks2);<span class="comment">% the period in samples for each HB</span>
farI=find(periodS/median(periodS)&gt;1.5);
<span class="keyword">if</span> median(periodS)/sRate&lt;0.5
    diary(<span class="string">'HBlog.txt'</span>)
    warning(<span class="string">'interval between HB is less than 0.5s, look at the figures!'</span>)
    diary <span class="string">off</span>
<span class="keyword">elseif</span> median(periodS)/sRate&gt;1.5
    diary(<span class="string">'HBlog.txt'</span>)
    warning(<span class="string">'interval between HB is more than 1.5s, look at the figures!'</span>)
    diary <span class="string">off</span>
<span class="keyword">else</span>
    <span class="keyword">if</span> ~isempty(farI)
        farT=Ipeaks2(farI)/sRate; <span class="comment">% this is far time, not what you think!</span>
        diary(<span class="string">'HBlog.txt'</span>)
        disp(<span class="string">'sparse heartbeats, you may want to look for missing HB after:'</span>);
        disp(num2str(farT));
        diary <span class="string">off</span>
    <span class="keyword">end</span>
    nearI=find(periodS/median(periodS)&lt;0.5);
    <span class="keyword">if</span> ~isempty(nearI)
        nearT=Ipeaks2(nearI)/sRate;
        diary(<span class="string">'HBlog.txt'</span>)
        disp(<span class="string">'close heartbeats, you may want to look for false HB detection after:'</span>);
        disp(num2str(nearT));
        diary <span class="string">off</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="comment">% ignore edges</span>
Ipeaks2in=Ipeaks2(Ipeaks2&gt;sampBefore);
Ipeaks2in=Ipeaks2in(Ipeaks2in&lt;(size(data,2)-sampBefore));
<span class="comment">% set template edges as ratio of the period</span>
<span class="keyword">if</span> isempty(afterHBs)
    afterHBs=0.7;
<span class="keyword">else</span>
    afterHBs=afterHBs/period3;
<span class="keyword">end</span>
<span class="keyword">if</span> isempty(beforeHBs)
    beforeHBs=0.3;
<span class="keyword">else</span>
    beforeHBs=beforeHBs/period3;
<span class="keyword">end</span>
<span class="comment">% make mcg trace for meanMEG</span>
<span class="keyword">if</span> posHB
    [templateHB,Period]=makeTempHB(meanMEG,sRate,Ipeaks2in,period3,sampBefore,figs,maxPeriod,beforeHBs,afterHBs,repressTime);
<span class="keyword">else</span>
    [templateHB,Period]=makeTempHB(-meanMEG,sRate,Ipeaks2in,period3,sampBefore,figs,maxPeriod,beforeHBs,afterHBs,repressTime);
<span class="keyword">end</span>

<span class="comment">%maxi=round(0.3*length(templateHB))+1;</span>
maxi=round(beforeHBs*Period*sRate)+1;
[~,mi]=max(templateHB(maxi-round(sRate/100):maxi+round(sRate/100)));
maxi=maxi-round(sRate/100)+mi-1;
</pre><img vspace="5" hspace="5" src="correctHBcdb_07.png" alt=""> <img vspace="5" hspace="5" src="correctHBcdb_08.png" alt=""> <h2>test R amplitude<a name="17"></a></h2><p>meanMEGdt=detrend(meanMEG,'linear',round(sRate:sRate:length(meanMEG)));</p><pre class="codeinput"><span class="keyword">if</span> length(ampFiltFreq)==1
    HighPassSpecObj=fdesign.highpass(<span class="string">'Fst,Fp,Ast,Ap'</span>,ampFiltFreq-1,ampFiltFreq,60,1,sRate);<span class="comment">%</span>
HighPassFilt=design(HighPassSpecObj ,<span class="string">'butter'</span>);
meanMEGampF = myFilt(meanMEG,HighPassFilt);
<span class="comment">% baseline correction again, just in case</span>
meanMEGampF=meanMEGampF-median(meanMEGampF);
<span class="keyword">elseif</span> length(ampFiltFreq)==2
    <span class="keyword">if</span> isequal(ampFiltFreq,[7 90])
        meanMEGampF=meanMEGf;
    <span class="keyword">else</span>
        BandPassSpecObjAmp=fdesign.bandpass(<span class="keyword">...</span>
            <span class="string">'Fst1,Fp1,Fp2,Fst2,Ast1,Ap,Ast2'</span>,<span class="keyword">...</span>
            ampFiltFreq(1)-1,ampFiltFreq(1),ampFiltFreq(2),ampFiltFreq(2)+10,60,1,60,sRate);
        BandPassFiltAmp=design(BandPassSpecObjAmp ,<span class="string">'butter'</span>);
        meanMEGampF = myFilt(meanMEG,BandPassFiltAmp);
        <span class="comment">% baseline correction again, just in case</span>
        meanMEGampF=meanMEGampF-median(meanMEGampF);
    <span class="keyword">end</span>
<span class="keyword">else</span>
    error(<span class="string">'wrong length of vector. one number (2) means hp filter, two ([2 90]) means bp'</span>)
<span class="keyword">end</span>

[p,Rlims]=assessAmp(templateHB,maxi,Ipeaks2in,meanMEGampF);
<span class="comment">% look for neg correlation between template peak and peaks, means trouble</span>
<span class="comment">% if there are too many</span>

<span class="keyword">if</span> posHB
    negp=find(p(:,1)&lt;ampLinThr);
<span class="keyword">else</span>
    negp=find(p(:,1)&gt;ampLinThr);
<span class="keyword">end</span>
<span class="keyword">if</span> ~isempty(negp)
    p(negp,1:2)=0;
    diary(<span class="string">'HBlog.txt'</span>)
    warning([<span class="string">'did not get good fit for amplitude test, assume average HB amplitude at '</span>,num2str(time(Ipeaks2in(negp)))])
    diary <span class="string">off</span>
<span class="keyword">end</span>
ampMMfit=p(:,1)+(p(:,2)./templateHB(maxi));
<span class="keyword">if</span> posHB
    MCG=makeMCG(templateHB,maxi,Rlims,Ipeaks2in,ampMMfit,length(meanMEG));
<span class="keyword">else</span>
    MCG=makeMCG(templateHB,maxi,Rlims,Ipeaks2in,-ampMMfit,length(meanMEG));
    MCG=-MCG;
<span class="keyword">end</span>
</pre><h2>remove mcg from each chan<a name="18"></a></h2><pre class="codeinput"><span class="comment">%make temp per chan</span>
sBef=maxi-1;
sAft=length(templateHB)-maxi;
HBtemp=HBbyChan(data,sRate,Ipeaks2in,sBef,sAft);
<span class="comment">% check SNR per chan</span>
sm50=round(sRate*0.05);
s0=maxi-sm50*3;
s1=maxi-sm50;
s2=maxi+sm50;
n=std(HBtemp(:,s0:s1)'); <span class="comment">%#ok&lt;*UDIM&gt;</span>
s=std(HBtemp(:,s1:s2)');
snr=s./n;
badSNR=find(snr&lt;=chanSnrThr);
<span class="keyword">if</span> figs
    timeTemp=1/sRate:1/sRate:size(HBtemp,2)/sRate;
    timeTemp=timeTemp-maxi/sRate;
    figure;plot(timeTemp,HBtemp',<span class="string">'k'</span>);hold <span class="string">on</span>;
    <span class="comment">%plot(maxi,HBtemp(find(HBsnr&gt;1.1),maxi),'g.')</span>
    [~,minI]=min(snr);
    plot(timeTemp,HBtemp(minI,:),<span class="string">'r'</span>);
    <span class="keyword">if</span> isempty(badSNR) || chanSnrThr==0
        title(<span class="string">'HB for all channels,red trace is worst SNR channel'</span>)
    <span class="keyword">else</span>
        plot(timeTemp(maxi),HBtemp(badSNR,maxi),<span class="string">'r.'</span>)
        title([<span class="string">'HB for all channels. red trace is worst SNR channel, dots mark channels with SNR &lt; '</span>,num2str(chanSnrThr)])
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="keyword">if</span> ~isempty(badSNR)
    <span class="keyword">if</span> length(find(snr&lt;=chanSnrThr))&gt;size(data,1)/2
        error(<span class="string">'too many channels have poor SNR. was there artifact?'</span>)
    <span class="keyword">end</span>
    <span class="keyword">if</span> ~chanSnrThr==0
        HBtemp(badSNR,:)=0;
        diary(<span class="string">'HBlog.txt'</span>)
        disp([<span class="string">'not including bad SNR channels, index no. '</span>,num2str(badSNR)])
        diary <span class="string">off</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="comment">% clear some memory</span>
meanData=mean(data);
MEGmean=meanMEG;
clear <span class="string">meanMEG*</span> <span class="string">topoTra*</span>
meanMEG=MEGmean;
clear <span class="string">MEGmean</span>;
<span class="comment">% prepare avg HB fig</span>
HBtimes=(Ipeaks2in-sampBefore)/sRate;
[avgHB,avgTimes]=meanHB(data(:,sampBefore+1:end-sampBefore),sRate,HBtimes);
<span class="comment">% clean</span>
display(<span class="string">'cleaning channels from template one by one, may take half a minute'</span>)
<span class="keyword">for</span> chani=1:size(HBtemp,1)
    <span class="keyword">if</span> posHB
        MCGall=makeMCGbyCh(HBtemp(chani,:),maxi,Rlims,Ipeaks2in,ampMMfit,length(meanMEG));
    <span class="keyword">else</span>
        MCGall=makeMCGbyCh(HBtemp(chani,:),maxi,Rlims,Ipeaks2in,-ampMMfit,length(meanMEG));
    <span class="keyword">end</span>
    data(chani,:)=data(chani,:)-MCGall;
<span class="keyword">end</span>
<span class="comment">%cleanData=data-MCGall;</span>
</pre><img vspace="5" hspace="5" src="correctHBcdb_09.png" alt=""> <h2>Plot average MEG channel before and after<a name="19"></a></h2><pre class="codeinput">figure;
<span class="keyword">if</span> isempty(ECG)
    plot(time,MCG,<span class="string">'k'</span>)
<span class="keyword">else</span>
    scale=max(abs(MCG(sampBefore+1:sampBefore+round(sRate*5))))/max(abs(mean(data(:,sampBefore+1:sampBefore+round(sRate*5)))));
    plot(time,meanMEG/scale,<span class="string">'k'</span>)
<span class="keyword">end</span>
hold <span class="string">on</span>
plot(time,meanData,<span class="string">'r'</span>)
plot(time,mean(data),<span class="string">'g'</span>)
<span class="keyword">if</span> isempty(ECG)
    legend(<span class="string">'MCG from template'</span>, <span class="string">'mean MEG'</span>,<span class="string">'mean clean MEG'</span>)
<span class="keyword">else</span>
    legend(<span class="string">'rescaled ECG'</span>, <span class="string">'mean MEG'</span>,<span class="string">'mean clean MEG'</span>)
<span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="correctHBcdb_10.png" alt=""> <img vspace="5" hspace="5" src="correctHBcdb_11.png" alt=""> <h2>Plot average HB (on average MEG) before and after<a name="20"></a></h2><pre class="codeinput">Rtopo=HBtemp(:,maxi);
<span class="keyword">if</span> figs
    <span class="keyword">if</span> isfield(figOptions,<span class="string">'layout'</span>)
        topo.avg=Rtopo;
        cfgp.xlim=[1,1];
        <span class="keyword">if</span> strcmp(cfgp.layout,<span class="string">'neuromag306mag.lay'</span>)
            cfgp.zlim=[-max(abs(topo.avg(magi))) max(abs(topo.avg(magi)))];
            figure;
            ft_topoplotER(cfgp,topo);
            title(<span class="string">'MAGNETOMETERS, TOPOGRAPHY OF R, 2nd sweep'</span>)
        <span class="keyword">else</span>
            cfgp.zlim=[-max(abs(Rtopo)) max(abs(Rtopo))];
            figure;
            ft_topoplotER(cfgp,topo);
            title (<span class="string">'TOPOGRAPHY OF R, 2nd sweep'</span>)
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
avgHBclean=meanHB(data(:,sampBefore+1:end-sampBefore),sRate,HBtimes);
figure;plot(avgTimes,mean(avgHB),<span class="string">'r'</span>)
hold <span class="string">on</span>
plot(avgTimes,mean(avgHBclean),<span class="string">'g'</span>)
title(<span class="string">'averaged heartbeat, before (red) and after'</span>)
<span class="comment">%display(['HB period (2nd sweep) is ',num2str(period4),'s']);</span>
<span class="keyword">if</span> ~isempty(bads);
    data(:,bads)=badData;
<span class="keyword">end</span>
<span class="comment">% plot avg HB before and after</span>

data=data(:,sampBefore+1:end-sampBefore);
</pre><img vspace="5" hspace="5" src="correctHBcdb_12.png" alt=""> <img vspace="5" hspace="5" src="correctHBcdb_13.png" alt=""> <h2>sanity check<a name="21"></a></h2><pre class="codeinput">[~,t0]=max(diff(smooth(templateHB,20)));
<span class="keyword">if</span> t0&gt;round(sRate/2)
    diary(<span class="string">'HBlog.txt'</span>)
    txt=[<span class="string">'insane, max(diff(templateHB)) is far, '</span>,num2str(round(1000*t0/sRate)),<span class="string">'ms. Is it HeartBeat at all?!?\n'</span>];
    fprintf(2,txt);
    diary(<span class="string">'off'</span>)
<span class="keyword">end</span>
EK=kurtosis(xcorr(templateHB))-3; <span class="comment">%excess kurtosis of autocorrelation should be high</span>
<span class="keyword">if</span> EK &lt;3
    txt=<span class="string">'insane, repetitive pattern, is it HeartBeat? not Alpha?!?\n'</span>;
    diary(<span class="string">'HBlog.txt'</span>)
    fprintf(2,txt);
    diary <span class="string">off</span>
<span class="keyword">end</span>
</pre><h2>internal functions<a name="22"></a></h2><pre class="codeinput"><span class="keyword">function</span> [tempe,period4]=makeTempHB(trace,sRate,peakIndex,period,sampBefore,figs,maxPeriod,beforeHBs,afterHBs,repressTime)
<span class="keyword">if</span> ~exist(<span class="string">'afterHBs'</span>,<span class="string">'var'</span>)
    afterHBs=0.7; <span class="comment">% after the T wave, before next qrs, 0.7 of period</span>
<span class="keyword">end</span>
<span class="keyword">if</span> ~exist(<span class="string">'beforeHBs'</span>,<span class="string">'var'</span>)
    beforeHBs=0.3;
<span class="keyword">end</span>
<span class="keyword">if</span> ~exist(<span class="string">'repressTime'</span>,<span class="string">'var'</span>)
    repressTime=20; <span class="comment">% how much time to supress</span>
<span class="keyword">end</span>
HB=zeros(size(trace,1),sampBefore*2+1);
<span class="keyword">for</span> epochi=1:length(peakIndex)
    HB=HB+trace(:,peakIndex(epochi)-sampBefore:peakIndex(epochi)+sampBefore);
<span class="keyword">end</span>
HB=HB/epochi;
period4=[]; <span class="comment">%#ok&lt;NASGU&gt;</span>
HBxc=xcorr(HB);
[~,ipxc]=findPeaks(HBxc,1.5,sRate*period*0.6); <span class="comment">% index peak xcorr</span>
<span class="keyword">if</span> length(ipxc)&gt;1
    nextPeak=ceil(length(ipxc)/2+0.5);
    period4=(ipxc(nextPeak)-ipxc(nextPeak-1))/sRate;
    <span class="comment">% else</span>
    xcorrByseg=false;
    <span class="keyword">if</span> length(trace)&gt;=2^20 <span class="comment">% test if version is later than 1011b</span>
        ver=version(<span class="string">'-release'</span>);
        <span class="keyword">if</span> ~strcmp(ver,<span class="string">'2011b'</span>)
            <span class="keyword">if</span> str2num(ver(1:end-1))&lt;=2011
                xcorrByseg=true;
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">if</span> xcorrByseg
        trace1=trace;
        difs=[];
        <span class="keyword">while</span> length(trace1)&gt;length(HB)*3 <span class="comment">%2^20</span>
            <span class="keyword">if</span> length(trace1)&gt;2^20
                trace2=trace1(1:2^20);
                trace1=trace1(2^20+1:end);
            <span class="keyword">else</span>
                trace2=trace1;
                trace1=0;
            <span class="keyword">end</span>
            xcCurrent=xcorr(trace2,HB);
            xcCurrent=xcCurrent(find(xcCurrent,1):end);
            [~,ipxcCur]=findPeaks(xcCurrent,1.5,sRate*period*0.6);
            difs=[difs,diff(ipxcCur)]; <span class="comment">%#ok&lt;AGROW&gt;</span>
        <span class="keyword">end</span>
        period4=median(difs(difs/sRate&lt;maxPeriod))/sRate;
    <span class="keyword">else</span>
        HBxc1=xcorr(trace,HB);
        [~,ipxc]=findPeaks(HBxc1,1.5,sRate*period*0.6); <span class="comment">% index peak xcorr</span>
        period4=median(diff(ipxc))/sRate;
    <span class="keyword">end</span>
<span class="keyword">else</span>
    warning(<span class="string">'could not find cross correlation within extended template, guessing period'</span>)
    period4=period;
<span class="keyword">end</span>
temp=HB(sampBefore-round(sRate*beforeHBs*period4):sampBefore+round(sRate*afterHBs*period4));
edgeRepressor=ones(size(temp));

reducVec=0:1/repressTime:1;
reducVec=reducVec(1:end-1);
edgeRepressor(1:length(reducVec))=reducVec;
edgeRepressor(end-length(reducVec)+1:end)=fliplr(reducVec);
tempe=temp-median(temp);
tempe=tempe.*edgeRepressor;
time=1/sRate:1/sRate:length(temp)/sRate;
time=time-(1-afterHBs)*period4;
<span class="keyword">if</span> figs
    figure;
    plot(time,tempe,<span class="string">'g'</span>)
    title(<span class="string">'template HB'</span>)
<span class="keyword">end</span>
tempe=double(tempe);

<span class="keyword">function</span> MCG=makeMCG(temp,maxTemp,Rlims,Ipeaks,amp,lengt)
MCG=zeros(1,lengt);
HBol=[]; <span class="comment">%overlap</span>
olCount=0;
<span class="comment">%[~,maxTemp]=max(temp(1:round(length(temp/2))));</span>
<span class="keyword">for</span> HBi=1:length(Ipeaks);
    s0=Ipeaks(HBi)-maxTemp+1;
    s1=Ipeaks(HBi)+length(temp)-maxTemp;
    <span class="keyword">if</span> sum(MCG(s0:s1))&gt;0
        overlap=find(MCG(s0:s1),1,<span class="string">'last'</span>);
        <span class="keyword">if</span> overlap&gt;0.2*length(temp)
            endPrev=round(0.2*length(temp));
        <span class="keyword">else</span>
            endPrev=overlap;
        <span class="keyword">end</span>
<span class="comment">%         sampDif=round(sRate/50);</span>
        reducVec=1:-1/endPrev:1/endPrev;
        reducVecLR=fliplr(reducVec);
        reducVec(end+1:length(temp))=0;
        reducVecLR(end+1:length(temp))=1;
        MCG(s0:s1)=MCG(s0:s1).*reducVec+temp.*reducVecLR;
        olCount=olCount+1;
        HBol(olCount)=HBi;
    <span class="keyword">else</span>
        MCG(s0:s1)=MCG(s0:s1)+temp;
    <span class="keyword">end</span>
    MCG(s0+Rlims(1)-1:s0+Rlims(2)-1)=temp(Rlims(1):Rlims(2))*amp(HBi);
<span class="keyword">end</span>
<span class="comment">% if ~isempty(HBol)</span>
<span class="comment">% diary('HBlog.txt')</span>
<span class="comment">% disp(['overlapping heartbeats at ',num2str(Ipeaks(HBol/sRate)),'s'])</span>
<span class="comment">% diary off</span>
<span class="comment">% end</span>
<span class="keyword">function</span> tempe=HBbyChan(trace,sRate,peakIndex,sampBefore,sampAfter,repressTime)
HB=zeros(size(trace,1),sampBefore+1+sampAfter);
<span class="comment">% average HBs</span>
<span class="keyword">for</span> epochi=1:length(peakIndex)
    HB=HB+trace(:,peakIndex(epochi)-sampBefore:peakIndex(epochi)+sampAfter);
<span class="keyword">end</span>
HB=HB/epochi;
<span class="comment">% reduce edges to zero</span>
edgeRepressor=ones(1,size(HB,2));
repressTime=round(sRate/50);
reducVec=0:1/repressTime:1;
reducVec=reducVec(1:end-1);
edgeRepressor(1:length(reducVec))=reducVec;
edgeRepressor(end-length(reducVec)+1:end)=fliplr(reducVec);
tempe=HB-repmat(mean(HB(:,[1:repressTime,end-repressTime:end]),2),1,size(HB,2));
tempe=tempe.*repmat(edgeRepressor,size(HB,1),1);
<span class="keyword">function</span> MCG=makeMCGbyCh(temp,maxTemp,Rlims,Ipeaks,amp,lengt)
MCG=zeros(size(temp,1),lengt);
<span class="keyword">for</span> HBi=1:length(Ipeaks);
    s0=Ipeaks(HBi)-maxTemp+1;
    s1=Ipeaks(HBi)+length(temp)-maxTemp;
    <span class="keyword">if</span> sum(MCG(1,s0:s1))&gt;0
        overlap=find(MCG(1,s0:s1),1,<span class="string">'last'</span>);
        <span class="keyword">if</span> overlap&gt;maxTemp/2; <span class="comment">% 0.2*size(temp,2)</span>
            endPrev=round(maxTemp/2); <span class="comment">% round(0.2*size(temp,2));</span>
        <span class="keyword">else</span>
            endPrev=overlap;
        <span class="keyword">end</span>
<span class="comment">%         sampDif=round(sRate/50);</span>
        reducVec=1:-1/endPrev:1/endPrev;
        reducVecLR=fliplr(reducVec);
        reducVec(end+1:size(temp,2))=0;
        reducVecLR(end+1:size(temp,2))=1;
        reducVec=repmat(reducVec,size(temp,1),1);
        reducVecLR=repmat(reducVecLR,size(temp,1),1);
        MCG(:,s0:s1)=MCG(:,s0:s1).*reducVec+temp.*reducVecLR;
    <span class="keyword">else</span>
        MCG(:,s0:s1)=MCG(:,s0:s1)+temp;
    <span class="keyword">end</span>
    MCG(:,s0+Rlims(1)-1:s0+Rlims(2)-1)=temp(:,Rlims(1):Rlims(2))*amp(HBi);
<span class="keyword">end</span>
<span class="keyword">function</span> xcr=XCORR(x,y,Rsamp)
xcorrByseg=false;
<span class="keyword">if</span> length(x)&gt;=2^20 <span class="comment">% test if version is later than 1011b</span>
    ver=version(<span class="string">'-release'</span>);
    <span class="keyword">if</span> ~strcmp(ver,<span class="string">'2011b'</span>)
        <span class="keyword">if</span> str2num(ver(1:end-1))&lt;=2011
            xcorrByseg=true;
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
[~,Rsamp]=max(y);
<span class="keyword">if</span> xcorrByseg
    trace1=x;
    xcr=[];

    <span class="keyword">while</span> length(trace1)&gt;length(y)<span class="comment">%2^20</span>
        <span class="keyword">if</span> length(trace1)&gt;2^20
            trace2=trace1(1:2^20);
            trace1=trace1(2^20+1:end);
        <span class="keyword">else</span>
            trace2=trace1;
            trace1=0;
        <span class="keyword">end</span>
        xcrPad=zeros(size(trace2));
        [xcCurrent,lags]=xcorr(trace2,y);
        xcCurrent=xcCurrent(lags&gt;=0);
        xcrPad=zeros(size(trace2));
        xcrPad(Rsamp:end)=xcCurrent(1:end-Rsamp+1);
        xcr=[xcr,xcrPad];
        <span class="comment">% FIXME xcorr (fftfilt) won't take it for more than 2^20</span>
    <span class="keyword">end</span>

<span class="keyword">else</span>
    [xcr,lags]=xcorr(x,y);
    xcr=xcr(lags&gt;=0);
    xcrPad=zeros(size(x));
    xcrPad(Rsamp:end)=xcr(1:end-Rsamp+1);
    xcr=xcrPad; <span class="comment">% sorry for switching variables</span>
<span class="keyword">end</span>
<span class="keyword">function</span> [p,Rlims]=assessAmp(templateHB,maxi,Ipeaks2in,meanMEG)
<span class="comment">%[~,maxi]=max(templateHB(1:round(length(templateHB/2))));</span>
bef=find(fliplr(templateHB(1:maxi))&lt;=0,1)-1;
aft=find(templateHB(maxi:end)&lt;=0,1)-1;
Rlims=[maxi-bef,maxi+aft]; <span class="comment">% check where R pulls the template above zero</span>
<span class="keyword">for</span> HBi=1:length(Ipeaks2in);
    s0=Ipeaks2in(HBi)-bef;
    s1=Ipeaks2in(HBi)+aft;
    x=templateHB(Rlims(1):Rlims(2));
    y=meanMEG(s0:s1);
    scalef=-round(log10(max([x,y]))); <span class="comment">% scaling factor for polyfit not to complain</span>
    x=x*10^scalef;
    y=y*10^scalef;
    pScaled=polyfit(x,y,1);
    pScaled(2)=pScaled(2).*10^-scalef;
    p(HBi,1:2)=pScaled; <span class="comment">%#ok&lt;AGROW&gt;</span>
<span class="keyword">end</span>
<span class="keyword">function</span> variable=default(field,value,cfg)
<span class="keyword">if</span> isfield(cfg,field)
    eval([<span class="string">'variable=cfg.'</span>,field,<span class="string">';'</span>])
<span class="keyword">else</span>
    variable=value;
<span class="keyword">end</span>
<span class="keyword">function</span> vecN=standard(vec) <span class="comment">% normalize data for display</span>
vecN=vec/median(abs(vec));
</pre><p class="footer"><br>
      Published with MATLAB&reg; 7.13<br></p></div><!--
##### SOURCE BEGIN #####
function [data,HBtimes,templateHB,Period,MCG,Rtopo]=correctHBcdb(data,sRate,figOptions,ECG,cfg)

% - data is a matrix with rows for channels, raw data, not filtered. it can
% also be a filename.mat, directing to data matrix file, or a 4D filename such
% as 'c1,rfhp0.1Hz'.
% - sRate is sampling rate
% - figOptions=false;
% if you want fieldtrip topoplot of HB (first and second sweeps) you have to have:
% figOptions.label=N by 1 cell arraay with channel names of data
% figOptions.layout='4D248.lay' for 4D users. I recommend
% 'neuromag306mag.lay' for neuromag users even if data includes also grads.
% - ECG can be ECG (useful for ctf users) or a mean of subset of MEG channels where the HB is
% visible. neuromag users can put there the mean of the magnetometers to
% clean both magnetometers and gradiometers included in data.
%
% HB components   
%     /\      _____         /\      _____     
% __ /  \  __/     \______ /  \  __/     \__...
%   /    \/               /    \/ 
%   Q  R  S     T
%
%
%% cfg
% you can change variables by placing them in cfg. 
% lots of thresholds can be set and filters factors.
%
% a bit about the FILTERS.
% PEAK detection is performed on meanMEGf. a highpass is recommended to
% eliminate drift, but also the T wave which is sometimes larger than the R.
% cfg.peakFiltFreq sets the bandpass freqs for this one.
% the AMPLITUDE of R is estimated, but then you may want a highpass filter
% only, not to cut down R peak. cfg.ampFiltFreq can set up this filter as bp or hp.
% when using xcorr or Abeles method a TEMPLATE HB is fitted to the ECG like
% trace (meanMEG). another filter can be used there, in order to supress T
% for better timing. when the R is small and T can help the template match
% leave some low frequencies in. use tempFiltFreq for this one.
% I added filtering option dataFiltFreq for the data (and meanMEG) to get rid of low
% frequencies (DC recordings). not performed by default.
%
%  - cfg.chanSnrThr (default 0) is the threshold (in z scores) that tell which channels are cleaned and which
% remain as are. use 0 to clean all.
%
%  - cfg.rThr (0.5) is the threshold for correlation between topographies of averaged R peak
% and a particular R peak, it determains which instances of HB will be
% taken to calculate the HB temporal template
%
%  - cfg.minPeriod (0.45) low limit for HB period
%
%  - cfg.maxPeriod (2) upper limit for HB period
%
%  - cfg.chanZthr (20) z-score for declaring bad channels. A channel is bad
%  if it surpasses this value for 3 seconds in the beginning of the
%
%  - cfg.jPad (1) how much to zero pad before and after jump
%
%  - cfg.jZthr (15) is a z-score over which the meanMEG is considered to
%  have jump artifact
%
%  - cfg.peakFiltFreq ([7 90]) is the band-pass filter used for the meanMEG data, before peak
% detection.
%
%  - cfg.tempFiltFreq (same as peakFiltFreq) is the filter used for
%  meanMEG template and meanMEG before template match takes place. when
%  T is large and R is small you may want to lower the highpass freq. It
%  can save the day but beware, tricky business.
%
%  - cfg.matchMethod can be 'xcorr' (default) or 'Abeles', it is how you find
% the match between a template HB and meanMEG / ECG recording. you can also
% use 'topo' and 'meanMEG' in order to define HB peaks on the topography
% trace or the mean(MEG) channel.
%
%  - cfg.ampFiltFreq (2) is a high-pass or band-pass filter used to test R
% peak amplitude. better use highpass only, although bp may improve linear
% fit between (unfiltered) template and filtered data.
%
%  - cfg.ampLinThr (0.25) is linear regression r threshold. if there is no ggood
%  fit between template QRS and an instance of a heart beat, amplitude will not
%  be assesed by r, the average HB amp will be given.
%
%  - cfg.afterHBs (0.7 of the period) is how long the template should continue after the 
% peak (seconds)
%
%  - cfg.beforeHBs (0.3 of the period) is when the template should start before the 
% peak (seconds)
%
%  - cfg.repressTime (20ms) is how much of the template to repress to zero on
%  the edges (ms)
%
% 4D users can run the function from the folder with the data ('c,*') file, with no
% input arguments:
% cleanData=correctHB;
% or like this cleanData=correctHB([],[],1); to get the figures.
% if you don't specify figure options you still get one before / after figure.
% added by Dr. Yuval Harpaz to Prof. Abeles' work
%
% Issues:
%
% - only R amplitude is corrected, may consider to change q s and t waves.
%
% - allow using a premade template, good for cleaning data in 2 pieces
%
% it works, try it!

%% default variables and parameters
if ~exist('figOptions','var')
    figOptions=1;
end
if isempty(figOptions)
    figs=false;
else
    figs=true;
end
if ~exist('ECG','var')
    ECG=[];
end
if ~exist('cfg','var')
    cfg=struct;
end
% uses default unless specified in the cfg
chanSnrThr=default('chanSnrThr',0,cfg);
rThr=default('rThr',0.5,cfg);
peakZthr=default('peakZthr',1.5,cfg);
minPeriod=default('minPeriod',0.45,cfg);
maxPeriod=default('maxPeriod',2,cfg);
chanZthr=default('chanZthr',20,cfg);
jPad=default('jPad',1,cfg);
jZthr=default('jZthr',15,cfg);
peakFiltFreq=default('peakFiltFreq',[7 90],cfg);
ampFiltFreq=default('ampFiltFreq',2,cfg);% [7 90] for band pass
tempFiltFreq=default('tempFiltFreq',peakFiltFreq,cfg);
dataFiltFreq=default('dataFiltFreq',0.1,cfg);
matchMethod=default('matchMethod','xcorr',cfg);
beforeHBs=default('beforeHBs',[],cfg); % how long the right side of template HB should be. when empty it gets 0.3*period
afterHBs=default('afterHBs',[],cfg); % how long the right side of template HB should be. when empty it gets 0.7*period
ampLinThr=default('ampLinThr',0.25,cfg);  % threshold for low amplitude HB, use average amplitude when below this ratio   
 

%% checking defaults for 4D data
% to use with data=[] and sRate=[];
if ~exist('data','var')
    data=[];
    sRate=[];
end
if ischar(data)
    if strcmp(data(end-3:end),'.mat') % read matrix from file 'data.mat'
        PWD=pwd;
        display(['loading ',PWD,'/',data,]);
        data=load(['./',data]);
        dataField=fieldnames(data);
        
        eval(['data=data.',dataField{1,1},';']);
    else % read 4D data from file name specified in 'data'
        cloc=strfind(data,'c');
        comaloc=strfind(data,',');
        if ~isempty(cloc) && ~isempty(comaloc)
            if comaloc(end)>cloc(1)
                var4DfileName=data;
            end
        end
    end
end

if isempty(data) || exist('var4DfileName','var');
    if ~exist('var4DfileName','var');
        try
            var4DfileName=ls('xc,lf_c,*');
        catch %#ok<CTCH>
            var4DfileName=ls('c,*');
        end
        var4DfileName=['./',var4DfileName(1:end-1)];
    end
    
    var4Dp=pdf4D(var4DfileName);
    sRate=double(get(var4Dp,'dr'));
    var4Dhdr = get(var4Dp, 'header');
    var4DnSamp=var4Dhdr.epoch_data{1,1}.pts_in_epoch;
    var4Dchi = channel_index(var4Dp, 'meg', 'name');
    display(['reading ',var4DfileName]);
    data = read_data_block(var4Dp,[1 var4DnSamp],var4Dchi);
    %data=double(data);
    if figs
        var4Dlabel=channel_label(var4Dp,var4Dchi)';
        if figOptions==1;
            clear figOptions
        end
        figOptions.label=var4Dlabel;
        figOptions.layout='4D248.lay';
    end
    clear var4D*
end

if ~isempty(ECG)
    meanMEG=ECG;
    %meanMEGdt=detrend(meanMEG,'linear',round(sRate:sRate:length(meanMEG)));
else
    meanMEG=double(mean(data));
end
repressTime=default('repressTime',round(sRate/50),cfg);
%% pad with zeros for templite slide
sampBefore=round(sRate*maxPeriod);
%time=1/sRate:1/sRate:size(data,2)/sRate;
time=-sampBefore/sRate:1/sRate:(size(data,2)+sampBefore)/sRate;
time=time(2:end);
origDataSize=size(data);
meanMEG=[zeros(1,sampBefore),meanMEG,zeros(1,sampBefore)];
data=[zeros(size(data,1),sampBefore),data,zeros(size(data,1),sampBefore)];

realDataSamp=[sampBefore+1,size(data,2)-sampBefore];
%% Filter data if requested
if ~isempty(dataFiltFreq)
    display('filtering the data')
    if length(dataFiltFreq)==2
        Fp1=dataFiltFreq(1);
        Fst1=max([0.01,Fp1-1]);
        ObjData=fdesign.bandpass(...
            'Fst1,Fp1,Fp2,Fst2,Ast1,Ap,Ast2',...
            Fst1,Fp1,dataFiltFreq(2),dataFiltFreq(2)+10,60,1,60,sRate);
    elseif length(dataFiltFreq)==1
        if dataFiltFreq<15
            ObjData=fdesign.highpass('Fst,Fp,Ast,Ap',max([dataFiltFreq-1,0.01]),dataFiltFreq,60,1,sRate);%
        elseif dataFiltFreq>=15
            ObjData=fdesign.lowpass('Fp,Fst,Ap,Ast',dataFiltFreq,dataFiltFreq+10,1,60,sRate);
        end
        FiltData=design(ObjData ,'butter');
    end
    data = myFilt(data,FiltData);
    meanMEG=myFilt(meanMEG,FiltData);
end
    
for chani=1:size(data,1)
    data(chani,:)=data(chani,:)-median(data(chani,:));
end
meanMEG=meanMEG-median(meanMEG);
%% filter mean MEG (or ECG)
% filtering to pass from 5-7Hz to 90-110Hz
if ~(peakFiltFreq(1)>1)
    Fst1=0.001;
else
    Fst1=peakFiltFreq(1)-1;
end
BandPassSpecObj=fdesign.bandpass(...
    'Fst1,Fp1,Fp2,Fst2,Ast1,Ap,Ast2',...
    Fst1,peakFiltFreq(1),peakFiltFreq(2),peakFiltFreq(2)+10,60,1,60,sRate);
BandPassFilt=design(BandPassSpecObj ,'butter');
meanMEGf = myFilt(meanMEG,BandPassFilt);
% baseline correction again, just in case
meanMEGf=meanMEGf-median(meanMEGf);

%% look for a noisy segment and noisy channels
% find bad channels, has to be noisy for 3 of the first 3 seconds
stdMEG=std(data(:,1:round(sRate))');
badc1=stdMEG>chanZthr*median(stdMEG);
stdMEG=std(data(:,round(sRate):round(2*sRate))');
badc2=stdMEG>chanZthr*median(stdMEG);
stdMEG=std(data(:,round(2*sRate):round(3*sRate))');
badc3=stdMEG>chanZthr*median(stdMEG);
badc=find((badc1+badc2+badc3)==3);
if ~isempty(badc)
    data(badc,:)=0;
end

% find jump or other huge artifact
zMEG=(meanMEGf-mean(meanMEGf))./std(meanMEGf);
jbeg=find(abs((zMEG))>jZthr,1);% 
j=find(abs((zMEG))>jZthr);
bads=[]; % bad samples
if ~isempty(jbeg)
    %jend=find(abs((zMEG))>zThr,1,'last');
    %jend2=find(abs(zMEG(jend:end))>1,1,'last')+jend-1;
    for jumpi=1:length(j)
        bads=[bads,j(jumpi)-round(sRate*jPad):j(jumpi)+sRate*jPad]; %#ok<AGROW>
    end
    %bads(bads<sampBefore+1)=sampBefore+1;
    bads=unique(bads);
    bads=bads(bads>0);
    badData=data(:,bads);
    %bads=(jbeg-round(sRate./2)):(jend2+round(sRate*0.5));
    data(:,bads)=0;
    if length(data)<2^19
        data=data-repmat(median(data,2),1,size(data,2));
    else
        for chani=1:size(data,1)
            data(chani,:)=data(chani,:)-median(data(chani,:),2);
        end
    end
    diary('HBlog.txt')
    warning(['jump? what''','s the noise at ',num2str(time(jbeg)),'s? zeroed noise from ',num2str(max([0,time(bads(1))])),' to ',num2str(time(bads(end)))]);
    diary off
    % end
else
    % baseline correction by removing the median of each channel
    if length(data)<2^19
        data=data-repmat(median(data,2),1,size(data,2));
    else
         for chani=1:size(data,1)
            data(chani,:)=data(chani,:)-median(data(chani,:),2);
         end
    end
end
if isempty(ECG)
    meanMEG=double(mean(data));
    meanMEGf = myFilt(meanMEG,BandPassFilt);
    meanMEGf=meanMEGf-median(meanMEGf);
end
%% peak detection on MCG (or ECG) signal
disp('looking for HB peaks')
[peaks, Ipeaks]=findPeaks(meanMEGf,peakZthr,round(sRate*minPeriod)); % 450ms interval minimum
% test if, by chance, the HB field is mainly negative
posHB=true;
if isempty(ECG)
        [peaksNeg, IpeaksNeg]=findPeaks(-meanMEGf,peakZthr,round(sRate*minPeriod));
    if median(peaksNeg)/median(peaks)>1.1
        diary('HBlog.txt')
        warning('NEGATIVE HB FIELD? if not, average selected MEG channels and give it as ECG');
        diary off
        period1=median(diff(IpeaksNeg))./sRate;
        if period1<2
            [peaks, Ipeaks]=findPeaks(-meanMEGf,peakZthr,round(sRate*period1*0.6));
            peaks=-peaks;
        else
            Ipeaks=IpeaksNeg;
            peaks=-peaksNeg;
        end
        posHB=false;
        %meanMEGf=-meanMEGf;
    else
        period1=median(diff(Ipeaks))./sRate;
        if period1<2 %#ok<*BDSCI> %try to improve peak detection if peak intervals are reasonable
            [peaks, Ipeaks]=findPeaks(meanMEGf,peakZthr,round(sRate*period1*0.6)); % 450ms interval
        end
    end
end
if figs
    figure;
    plot(time,meanMEGf)
    hold on
    plot(time(Ipeaks), peaks,'ro')
    title('Peak detection on mean MEG (or ECG) trace, OK if many of them are not HB')
    xlim([1 100])
end
%% get topography
if figs
    if isfield(figOptions,'layout') && isfield(figOptions,'label')
        topo={};
        topo.avg=median(data(:,Ipeaks),2);
        topo.time=0;
        topo.label=figOptions.label;
        topo.dimord='chan_time';
        cfgp=[];
        cfgp.layout=figOptions.layout;
        if ~isempty(badc)
            cfgp.channel=setdiff(1:length(topo.label),badc);
        end
        if strcmp(cfgp.layout,'neuromag306mag.lay')
            [~,magi]=ismember({'MEG0111';'MEG0121';'MEG0131';'MEG0141';'MEG0211';'MEG0221';'MEG0231';'MEG0241';'MEG0311';'MEG0321';'MEG0331';'MEG0341';'MEG0411';'MEG0421';'MEG0431';'MEG0441';'MEG0511';'MEG0521';'MEG0531';'MEG0541';'MEG0611';'MEG0621';'MEG0631';'MEG0641';'MEG0711';'MEG0721';'MEG0731';'MEG0741';'MEG0811';'MEG0821';'MEG0911';'MEG0921';'MEG0931';'MEG0941';'MEG1011';'MEG1021';'MEG1031';'MEG1041';'MEG1111';'MEG1121';'MEG1131';'MEG1141';'MEG1211';'MEG1221';'MEG1231';'MEG1241';'MEG1311';'MEG1321';'MEG1331';'MEG1341';'MEG1411';'MEG1421';'MEG1431';'MEG1441';'MEG1511';'MEG1521';'MEG1531';'MEG1541';'MEG1611';'MEG1621';'MEG1631';'MEG1641';'MEG1711';'MEG1721';'MEG1731';'MEG1741';'MEG1811';'MEG1821';'MEG1831';'MEG1841';'MEG1911';'MEG1921';'MEG1931';'MEG1941';'MEG2011';'MEG2021';'MEG2031';'MEG2041';'MEG2111';'MEG2121';'MEG2131';'MEG2141';'MEG2211';'MEG2221';'MEG2231';'MEG2241';'MEG2311';'MEG2321';'MEG2331';'MEG2341';'MEG2411';'MEG2421';'MEG2431';'MEG2441';'MEG2511';'MEG2521';'MEG2531';'MEG2541';'MEG2611';'MEG2621';'MEG2631';'MEG2641'},topo.label);
            %topo.avg=topo.avg(chi);
            %topo.label=topo.label(chi);
            cfgp.xlim=[1,1];
            cfgp.zlim=[-max(abs(topo.avg(magi))) max(abs(topo.avg(magi)))];
            figure;
            ft_topoplotER(cfgp,topo);
            title('MAGNETOMETERS, TOPOGRAPHY OF R')
            % cfg.layout='neuromag306planar.lay';
            % grd=topo.avg;
            % grd(chi)=0;
            % cfg.zlim=[-max(abs(grd)) max(abs(grd))];
            % figure;
            % ft_topoplotER(cfg,topo);
            % title('GRADIOMETERS')
        else
            %cfg.channel={'MEG0111';'MEG0121';'MEG0131';'MEG0141';'MEG0211';'MEG0221';'MEG0231';'MEG0241';'MEG0311';'MEG0321';'MEG0331';'MEG0341';'MEG0411';'MEG0421';'MEG0431';'MEG0441';'MEG0511';'MEG0521';'MEG0531';'MEG0541';'MEG0611';'MEG0621';'MEG0631';'MEG0641';'MEG0711';'MEG0721';'MEG0731';'MEG0741';'MEG0811';'MEG0821';'MEG0911';'MEG0921';'MEG0931';'MEG0941';'MEG1011';'MEG1021';'MEG1031';'MEG1041';'MEG1111';'MEG1121';'MEG1131';'MEG1141';'MEG1211';'MEG1221';'MEG1231';'MEG1241';'MEG1311';'MEG1321';'MEG1331';'MEG1341';'MEG1411';'MEG1421';'MEG1431';'MEG1441';'MEG1511';'MEG1521';'MEG1531';'MEG1541';'MEG1611';'MEG1621';'MEG1631';'MEG1641';'MEG1711';'MEG1721';'MEG1731';'MEG1741';'MEG1811';'MEG1821';'MEG1831';'MEG1841';'MEG1911';'MEG1921';'MEG1931';'MEG1941';'MEG2011';'MEG2021';'MEG2031';'MEG2041';'MEG2111';'MEG2121';'MEG2131';'MEG2141';'MEG2211';'MEG2221';'MEG2231';'MEG2241';'MEG2311';'MEG2321';'MEG2331';'MEG2341';'MEG2411';'MEG2421';'MEG2431';'MEG2441';'MEG2511';'MEG2521';'MEG2531';'MEG2541';'MEG2611';'MEG2621';'MEG2631';'MEG2641'};
            %cfg.interpolation='linear';
            cfgp.xlim=[1,1];
            cfgp.zlim=[-max(abs(topo.avg)) max(abs(topo.avg))];
            figure;
            ft_topoplotER(cfgp,topo);
            title('TOPOGRAPHY OF R')
            
        end
    else
        warning('no topoplot without labels and layout fields! see figOptions options')
    end
end
topoTrace=median(data(:,Ipeaks),2)'*data;
topoTrace=myFilt(topoTrace,BandPassFilt);
topoTrace=topoTrace-median(topoTrace);
% if ~posHB
%     meanMEGN=meanMEGf./max(-meanMEGf(1:round(sRate*10)));
%     topoTraceN=-topoTrace./max(topoTrace(1:round(sRate*10)));
% else
%     topoTraceN=topoTrace./max(topoTrace(1:round(sRate*10)));
%     meanMEGN=meanMEGf./max(meanMEGf(1:round(sRate*10)));
% end
meanMEGN=standard(meanMEGf);
topoTraceN=standard(topoTrace);
if ~posHB
    topoTraceN=-topoTraceN;
end


%% check if topo of every peak is correlated to average topo
r=corr(data(:,Ipeaks),median(data(:,Ipeaks),2));
if figs
    figure;
    plot(time,topoTraceN)
    hold on
    plot(time,meanMEGN,'r')
    plot(time(Ipeaks(r>0.5)),meanMEGN(Ipeaks(r>0.5)),'g.');
    legend('topoTrace','meanMEG','r data-topo > 0.5')
    figure;
    plot(time,topoTraceN)
    hold on
    plot(time,meanMEGN,'r')
    plot(time(Ipeaks(r>0.5)),meanMEGN(Ipeaks(r>0.5)),'g.');
    legend('topoTrace','meanMEG','r data-topo > 0.5')
    xlim([1 11]);
    title('Zoom in to see single heartbeats')
    
end
%% average good HB and make a template
IpeaksR=Ipeaks(r>0.5);
IpeaksR=IpeaksR(IpeaksR>sampBefore);
IpeaksR=IpeaksR(IpeaksR<(size(data,2)-sampBefore));
period2=diff(IpeaksR)/sRate; % estimate period
period2=median(period2(period2<maxPeriod)); % less than 2s

%LowPassSpecObj=fdesign.lowpass('Fp,Fst,Ap,Ast',45,55,1,60,sRate);
if tempFiltFreq==peakFiltFreq
    meanMEGxcrF=meanMEGf;
else
    if length(tempFiltFreq)==2
        Fp1=tempFiltFreq(1);
        Fst1=max([0.01,Fp1-1]);
        ObjXcr=fdesign.bandpass(...
            'Fst1,Fp1,Fp2,Fst2,Ast1,Ap,Ast2',...
            Fst1,Fp1,tempFiltFreq(2),tempFiltFreq(2)+10,60,1,60,sRate);
    elseif length(tempFiltFreq)==1
        if tempFiltFreq<15
            ObjXcr=fdesign.highpass('Fst,Fp,Ast,Ap',max([tempFiltFreq-1,0.01]),tempFiltFreq,60,1,sRate);%
        elseif tempFiltFreq>=15
            ObjXcr=fdesign.lowpass('Fp,Fst,Ap,Ast',tempFiltFreq,tempFiltFreq+10,1,60,sRate);
        end
        FiltXcr=design(ObjXcr ,'butter');
        meanMEGxcrF = myFilt(meanMEG,FiltXcr);
    end
end
    
    
% meanMEGxcrF = myFilt(meanMEG,BandPassFiltXcr);
meanMEGxcrF=meanMEGxcrF-median(meanMEGxcrF);
if posHB
    [temp1e,period3]=makeTempHB(meanMEGxcrF,sRate,IpeaksR,period2,sampBefore,figs,maxPeriod);
else
    [temp1e,period3]=makeTempHB(-meanMEGxcrF,sRate,IpeaksR,period2,sampBefore,figs,maxPeriod);
end
%% find xcorr between template and meanMEG
maxi=round(0.3*length(temp1e))+1; %maxi is where the R peak in the template
[~,mi]=max(temp1e(maxi-round(sRate/100):maxi+round(sRate/100)));
maxi=maxi-round(sRate/100)+mi-1;
if posHB
    meanMEGpos=meanMEGxcrF;
else
    meanMEGpos=-meanMEGxcrF;
end
switch matchMethod
    case 'xcorr'
        matchTrace=XCORR(meanMEGpos,temp1e,maxi);
    case 'Abeles'
        [snr,signal]=match_temp(meanMEGxcrF,temp1e,maxi);
        matchTrace=snr;
    case 'topo'
        matchTrace=topoTrace;
    case 'meanMEG'
        matchTrace=meanMEGf;
end


if figs
    figure;
    plot(time,topoTraceN)
    hold on
    plot(time,meanMEGN,'r')
    if posHB
        plot(time,standard(matchTrace),'g');
    else
        plot(time,-standard(matchTrace),'g');
    end
    legend('topoTrace','meanMEG','temp xcorr')
    xlim([1 100])
end
%% second sweep
%% find peaks on xcorr trace
[peaks2, Ipeaks2]=findPeaks(matchTrace,peakZthr,round(sRate*period3*0.65)); % no peaks closer than 60% of period
if figs
    figure;
    if posHB
        plot(time,matchTrace)
        hold on
        plot(time(Ipeaks2), peaks2,'ro')
    else
        plot(time,-matchTrace)
        hold on
        plot(time(Ipeaks2), -peaks2,'ro')
    end
    title('2nd sweep peak detection, based on template matching')
    xlim([1 100])
end
% checking results
periodS=diff(Ipeaks2);% the period in samples for each HB
farI=find(periodS/median(periodS)>1.5);
if median(periodS)/sRate<0.5
    diary('HBlog.txt')
    warning('interval between HB is less than 0.5s, look at the figures!')
    diary off
elseif median(periodS)/sRate>1.5
    diary('HBlog.txt')
    warning('interval between HB is more than 1.5s, look at the figures!')
    diary off
else
    if ~isempty(farI)
        farT=Ipeaks2(farI)/sRate; % this is far time, not what you think!
        diary('HBlog.txt')
        disp('sparse heartbeats, you may want to look for missing HB after:');
        disp(num2str(farT));
        diary off
    end
    nearI=find(periodS/median(periodS)<0.5);
    if ~isempty(nearI)
        nearT=Ipeaks2(nearI)/sRate;
        diary('HBlog.txt')
        disp('close heartbeats, you may want to look for false HB detection after:');
        disp(num2str(nearT));
        diary off
    end
end
% ignore edges
Ipeaks2in=Ipeaks2(Ipeaks2>sampBefore);
Ipeaks2in=Ipeaks2in(Ipeaks2in<(size(data,2)-sampBefore));
% set template edges as ratio of the period
if isempty(afterHBs)
    afterHBs=0.7;
else
    afterHBs=afterHBs/period3;
end
if isempty(beforeHBs)
    beforeHBs=0.3;
else
    beforeHBs=beforeHBs/period3;
end
% make mcg trace for meanMEG
if posHB
    [templateHB,Period]=makeTempHB(meanMEG,sRate,Ipeaks2in,period3,sampBefore,figs,maxPeriod,beforeHBs,afterHBs,repressTime);
else
    [templateHB,Period]=makeTempHB(-meanMEG,sRate,Ipeaks2in,period3,sampBefore,figs,maxPeriod,beforeHBs,afterHBs,repressTime);
end

%maxi=round(0.3*length(templateHB))+1;
maxi=round(beforeHBs*Period*sRate)+1;
[~,mi]=max(templateHB(maxi-round(sRate/100):maxi+round(sRate/100)));
maxi=maxi-round(sRate/100)+mi-1;
%% test R amplitude
% meanMEGdt=detrend(meanMEG,'linear',round(sRate:sRate:length(meanMEG)));
if length(ampFiltFreq)==1
    HighPassSpecObj=fdesign.highpass('Fst,Fp,Ast,Ap',ampFiltFreq-1,ampFiltFreq,60,1,sRate);%
HighPassFilt=design(HighPassSpecObj ,'butter');
meanMEGampF = myFilt(meanMEG,HighPassFilt);
% baseline correction again, just in case
meanMEGampF=meanMEGampF-median(meanMEGampF);
elseif length(ampFiltFreq)==2
    if isequal(ampFiltFreq,[7 90])
        meanMEGampF=meanMEGf;
    else
        BandPassSpecObjAmp=fdesign.bandpass(...
            'Fst1,Fp1,Fp2,Fst2,Ast1,Ap,Ast2',...
            ampFiltFreq(1)-1,ampFiltFreq(1),ampFiltFreq(2),ampFiltFreq(2)+10,60,1,60,sRate);
        BandPassFiltAmp=design(BandPassSpecObjAmp ,'butter');
        meanMEGampF = myFilt(meanMEG,BandPassFiltAmp);
        % baseline correction again, just in case
        meanMEGampF=meanMEGampF-median(meanMEGampF);
    end
else
    error('wrong length of vector. one number (2) means hp filter, two ([2 90]) means bp')
end

[p,Rlims]=assessAmp(templateHB,maxi,Ipeaks2in,meanMEGampF);
% look for neg correlation between template peak and peaks, means trouble
% if there are too many

if posHB
    negp=find(p(:,1)<ampLinThr);
else
    negp=find(p(:,1)>ampLinThr);
end
if ~isempty(negp)
    p(negp,1:2)=0;
    diary('HBlog.txt')
    warning(['did not get good fit for amplitude test, assume average HB amplitude at ',num2str(time(Ipeaks2in(negp)))])
    diary off
end
ampMMfit=p(:,1)+(p(:,2)./templateHB(maxi));
if posHB
    MCG=makeMCG(templateHB,maxi,Rlims,Ipeaks2in,ampMMfit,length(meanMEG));
else
    MCG=makeMCG(templateHB,maxi,Rlims,Ipeaks2in,-ampMMfit,length(meanMEG));
    MCG=-MCG;
end

%% remove mcg from each chan
%make temp per chan
sBef=maxi-1;
sAft=length(templateHB)-maxi;
HBtemp=HBbyChan(data,sRate,Ipeaks2in,sBef,sAft);
% check SNR per chan
sm50=round(sRate*0.05);
s0=maxi-sm50*3;
s1=maxi-sm50;
s2=maxi+sm50;
n=std(HBtemp(:,s0:s1)'); %#ok<*UDIM>
s=std(HBtemp(:,s1:s2)');
snr=s./n;
badSNR=find(snr<=chanSnrThr);
if figs
    timeTemp=1/sRate:1/sRate:size(HBtemp,2)/sRate;
    timeTemp=timeTemp-maxi/sRate;
    figure;plot(timeTemp,HBtemp','k');hold on;
    %plot(maxi,HBtemp(find(HBsnr>1.1),maxi),'g.')
    [~,minI]=min(snr);
    plot(timeTemp,HBtemp(minI,:),'r');
    if isempty(badSNR) || chanSnrThr==0
        title('HB for all channels,red trace is worst SNR channel')
    else
        plot(timeTemp(maxi),HBtemp(badSNR,maxi),'r.')
        title(['HB for all channels. red trace is worst SNR channel, dots mark channels with SNR < ',num2str(chanSnrThr)])
    end
end
if ~isempty(badSNR)
    if length(find(snr<=chanSnrThr))>size(data,1)/2
        error('too many channels have poor SNR. was there artifact?')
    end
    if ~chanSnrThr==0
        HBtemp(badSNR,:)=0;
        diary('HBlog.txt')
        disp(['not including bad SNR channels, index no. ',num2str(badSNR)])
        diary off
    end
end
% clear some memory
meanData=mean(data);
MEGmean=meanMEG;
clear meanMEG* topoTra*
meanMEG=MEGmean;
clear MEGmean;
% prepare avg HB fig
HBtimes=(Ipeaks2in-sampBefore)/sRate;
[avgHB,avgTimes]=meanHB(data(:,sampBefore+1:end-sampBefore),sRate,HBtimes);
% clean
display('cleaning channels from template one by one, may take half a minute')
for chani=1:size(HBtemp,1)
    if posHB
        MCGall=makeMCGbyCh(HBtemp(chani,:),maxi,Rlims,Ipeaks2in,ampMMfit,length(meanMEG));
    else
        MCGall=makeMCGbyCh(HBtemp(chani,:),maxi,Rlims,Ipeaks2in,-ampMMfit,length(meanMEG));
    end
    data(chani,:)=data(chani,:)-MCGall;
end
%cleanData=data-MCGall;
%% Plot average MEG channel before and after
figure;
if isempty(ECG)
    plot(time,MCG,'k')
else
    scale=max(abs(MCG(sampBefore+1:sampBefore+round(sRate*5))))/max(abs(mean(data(:,sampBefore+1:sampBefore+round(sRate*5)))));
    plot(time,meanMEG/scale,'k')
end
hold on
plot(time,meanData,'r')
plot(time,mean(data),'g')
if isempty(ECG)
    legend('MCG from template', 'mean MEG','mean clean MEG')
else
    legend('rescaled ECG', 'mean MEG','mean clean MEG')
end
figure;
if isempty(ECG)
    plot(time,MCG,'k')
else
    scale=max(abs(MCG(sampBefore+1:sampBefore+round(sRate*5))))/max(abs(mean(data(:,sampBefore+1:sampBefore+round(sRate*5)))));
    plot(time,meanMEG/scale,'k')
end
hold on
plot(time,meanData,'r')
plot(time,mean(data),'g')
if isempty(ECG)
    legend('MCG from template', 'mean MEG','mean clean MEG')
else
    legend('rescaled ECG', 'mean MEG','mean clean MEG')
end
xlim([1 3]);
title('Zoom in to see chained template')
%% Plot average HB (on average MEG) before and after
Rtopo=HBtemp(:,maxi);
if figs
    if isfield(figOptions,'layout')
        topo.avg=Rtopo;
        cfgp.xlim=[1,1];
        if strcmp(cfgp.layout,'neuromag306mag.lay')
            cfgp.zlim=[-max(abs(topo.avg(magi))) max(abs(topo.avg(magi)))];
            figure;
            ft_topoplotER(cfgp,topo);
            title('MAGNETOMETERS, TOPOGRAPHY OF R, 2nd sweep')
        else
            cfgp.zlim=[-max(abs(Rtopo)) max(abs(Rtopo))];
            figure;
            ft_topoplotER(cfgp,topo);
            title ('TOPOGRAPHY OF R, 2nd sweep')
        end
    end
end
avgHBclean=meanHB(data(:,sampBefore+1:end-sampBefore),sRate,HBtimes);
figure;plot(avgTimes,mean(avgHB),'r')
hold on
plot(avgTimes,mean(avgHBclean),'g')
title('averaged heartbeat, before (red) and after')
%display(['HB period (2nd sweep) is ',num2str(period4),'s']);
if ~isempty(bads);
    data(:,bads)=badData;
end
% plot avg HB before and after

data=data(:,sampBefore+1:end-sampBefore);
%% sanity check
[~,t0]=max(diff(smooth(templateHB,20)));
if t0>round(sRate/2)
    diary('HBlog.txt')
    txt=['insane, max(diff(templateHB)) is far, ',num2str(round(1000*t0/sRate)),'ms. Is it HeartBeat at all?!?\n'];
    fprintf(2,txt);
    diary('off')
end
EK=kurtosis(xcorr(templateHB))-3; %excess kurtosis of autocorrelation should be high
if EK <3
    txt='insane, repetitive pattern, is it HeartBeat? not Alpha?!?\n';
    diary('HBlog.txt')
    fprintf(2,txt);
    diary off
end

%% internal functions
function [tempe,period4]=makeTempHB(trace,sRate,peakIndex,period,sampBefore,figs,maxPeriod,beforeHBs,afterHBs,repressTime)
if ~exist('afterHBs','var')
    afterHBs=0.7; % after the T wave, before next qrs, 0.7 of period
end
if ~exist('beforeHBs','var')
    beforeHBs=0.3; 
end
if ~exist('repressTime','var')
    repressTime=20; % how much time to supress
end
HB=zeros(size(trace,1),sampBefore*2+1);
for epochi=1:length(peakIndex)
    HB=HB+trace(:,peakIndex(epochi)-sampBefore:peakIndex(epochi)+sampBefore);
end
HB=HB/epochi;
period4=[]; %#ok<NASGU>
HBxc=xcorr(HB);
[~,ipxc]=findPeaks(HBxc,1.5,sRate*period*0.6); % index peak xcorr
if length(ipxc)>1
    nextPeak=ceil(length(ipxc)/2+0.5);
    period4=(ipxc(nextPeak)-ipxc(nextPeak-1))/sRate;
    % else
    xcorrByseg=false;
    if length(trace)>=2^20 % test if version is later than 1011b
        ver=version('-release');
        if ~strcmp(ver,'2011b')
            if str2num(ver(1:end-1))<=2011
                xcorrByseg=true;
            end
        end
    end
    if xcorrByseg
        trace1=trace;
        difs=[];
        while length(trace1)>length(HB)*3 %2^20
            if length(trace1)>2^20
                trace2=trace1(1:2^20);
                trace1=trace1(2^20+1:end);
            else
                trace2=trace1;
                trace1=0;
            end
            xcCurrent=xcorr(trace2,HB);
            xcCurrent=xcCurrent(find(xcCurrent,1):end);
            [~,ipxcCur]=findPeaks(xcCurrent,1.5,sRate*period*0.6);
            difs=[difs,diff(ipxcCur)]; %#ok<AGROW>
        end
        period4=median(difs(difs/sRate<maxPeriod))/sRate;
    else
        HBxc1=xcorr(trace,HB);
        [~,ipxc]=findPeaks(HBxc1,1.5,sRate*period*0.6); % index peak xcorr
        period4=median(diff(ipxc))/sRate;
    end
else
    warning('could not find cross correlation within extended template, guessing period')
    period4=period;
end
temp=HB(sampBefore-round(sRate*beforeHBs*period4):sampBefore+round(sRate*afterHBs*period4));
edgeRepressor=ones(size(temp));

reducVec=0:1/repressTime:1;
reducVec=reducVec(1:end-1);
edgeRepressor(1:length(reducVec))=reducVec;
edgeRepressor(end-length(reducVec)+1:end)=fliplr(reducVec);
tempe=temp-median(temp);
tempe=tempe.*edgeRepressor;
time=1/sRate:1/sRate:length(temp)/sRate;
time=time-(1-afterHBs)*period4;
if figs
    figure;
    plot(time,tempe,'g')
    title('template HB')
end
tempe=double(tempe);

function MCG=makeMCG(temp,maxTemp,Rlims,Ipeaks,amp,lengt)
MCG=zeros(1,lengt);
HBol=[]; %overlap
olCount=0;
%[~,maxTemp]=max(temp(1:round(length(temp/2))));
for HBi=1:length(Ipeaks);
    s0=Ipeaks(HBi)-maxTemp+1;
    s1=Ipeaks(HBi)+length(temp)-maxTemp;
    if sum(MCG(s0:s1))>0
        overlap=find(MCG(s0:s1),1,'last');
        if overlap>0.2*length(temp)
            endPrev=round(0.2*length(temp));
        else
            endPrev=overlap;
        end
%         sampDif=round(sRate/50);
        reducVec=1:-1/endPrev:1/endPrev;
        reducVecLR=fliplr(reducVec);
        reducVec(end+1:length(temp))=0;
        reducVecLR(end+1:length(temp))=1;
        MCG(s0:s1)=MCG(s0:s1).*reducVec+temp.*reducVecLR;
        olCount=olCount+1;
        HBol(olCount)=HBi;
    else
        MCG(s0:s1)=MCG(s0:s1)+temp;
    end
    MCG(s0+Rlims(1)-1:s0+Rlims(2)-1)=temp(Rlims(1):Rlims(2))*amp(HBi);
end
% if ~isempty(HBol)
% diary('HBlog.txt')
% disp(['overlapping heartbeats at ',num2str(Ipeaks(HBol/sRate)),'s'])
% diary off
% end
function tempe=HBbyChan(trace,sRate,peakIndex,sampBefore,sampAfter,repressTime)
HB=zeros(size(trace,1),sampBefore+1+sampAfter);
% average HBs
for epochi=1:length(peakIndex)
    HB=HB+trace(:,peakIndex(epochi)-sampBefore:peakIndex(epochi)+sampAfter);
end
HB=HB/epochi;
% reduce edges to zero
edgeRepressor=ones(1,size(HB,2));
repressTime=round(sRate/50);
reducVec=0:1/repressTime:1;
reducVec=reducVec(1:end-1);
edgeRepressor(1:length(reducVec))=reducVec;
edgeRepressor(end-length(reducVec)+1:end)=fliplr(reducVec);
tempe=HB-repmat(mean(HB(:,[1:repressTime,end-repressTime:end]),2),1,size(HB,2));
tempe=tempe.*repmat(edgeRepressor,size(HB,1),1);
function MCG=makeMCGbyCh(temp,maxTemp,Rlims,Ipeaks,amp,lengt)
MCG=zeros(size(temp,1),lengt);
for HBi=1:length(Ipeaks);
    s0=Ipeaks(HBi)-maxTemp+1;
    s1=Ipeaks(HBi)+length(temp)-maxTemp;
    if sum(MCG(1,s0:s1))>0
        overlap=find(MCG(1,s0:s1),1,'last');
        if overlap>maxTemp/2; % 0.2*size(temp,2)
            endPrev=round(maxTemp/2); % round(0.2*size(temp,2));
        else
            endPrev=overlap;
        end
%         sampDif=round(sRate/50);
        reducVec=1:-1/endPrev:1/endPrev;
        reducVecLR=fliplr(reducVec);
        reducVec(end+1:size(temp,2))=0;
        reducVecLR(end+1:size(temp,2))=1;
        reducVec=repmat(reducVec,size(temp,1),1);
        reducVecLR=repmat(reducVecLR,size(temp,1),1);
        MCG(:,s0:s1)=MCG(:,s0:s1).*reducVec+temp.*reducVecLR;
    else
        MCG(:,s0:s1)=MCG(:,s0:s1)+temp;
    end
    MCG(:,s0+Rlims(1)-1:s0+Rlims(2)-1)=temp(:,Rlims(1):Rlims(2))*amp(HBi);
end
function xcr=XCORR(x,y,Rsamp)
xcorrByseg=false;
if length(x)>=2^20 % test if version is later than 1011b
    ver=version('-release');
    if ~strcmp(ver,'2011b')
        if str2num(ver(1:end-1))<=2011
            xcorrByseg=true;
        end
    end
end
[~,Rsamp]=max(y);
if xcorrByseg
    trace1=x;
    xcr=[];
    
    while length(trace1)>length(y)%2^20
        if length(trace1)>2^20
            trace2=trace1(1:2^20);
            trace1=trace1(2^20+1:end);
        else
            trace2=trace1;
            trace1=0;
        end
        xcrPad=zeros(size(trace2));
        [xcCurrent,lags]=xcorr(trace2,y);
        xcCurrent=xcCurrent(lags>=0);
        xcrPad=zeros(size(trace2));
        xcrPad(Rsamp:end)=xcCurrent(1:end-Rsamp+1);
        xcr=[xcr,xcrPad];
        % FIXME xcorr (fftfilt) won't take it for more than 2^20
    end
    
else
    [xcr,lags]=xcorr(x,y);
    xcr=xcr(lags>=0);
    xcrPad=zeros(size(x));
    xcrPad(Rsamp:end)=xcr(1:end-Rsamp+1);
    xcr=xcrPad; % sorry for switching variables
end
function [p,Rlims]=assessAmp(templateHB,maxi,Ipeaks2in,meanMEG)
%[~,maxi]=max(templateHB(1:round(length(templateHB/2))));
bef=find(fliplr(templateHB(1:maxi))<=0,1)-1;
aft=find(templateHB(maxi:end)<=0,1)-1;
Rlims=[maxi-bef,maxi+aft]; % check where R pulls the template above zero
for HBi=1:length(Ipeaks2in);
    s0=Ipeaks2in(HBi)-bef;
    s1=Ipeaks2in(HBi)+aft;
    x=templateHB(Rlims(1):Rlims(2));
    y=meanMEG(s0:s1);
    scalef=-round(log10(max([x,y]))); % scaling factor for polyfit not to complain
    x=x*10^scalef;
    y=y*10^scalef;
    pScaled=polyfit(x,y,1);
    pScaled(2)=pScaled(2).*10^-scalef;
    p(HBi,1:2)=pScaled; %#ok<AGROW>
end
function variable=default(field,value,cfg)
if isfield(cfg,field)
    eval(['variable=cfg.',field,';'])
else
    variable=value;
end
function vecN=standard(vec) % normalize data for display
vecN=vec/median(abs(vec));

##### SOURCE END #####
--></body></html>
